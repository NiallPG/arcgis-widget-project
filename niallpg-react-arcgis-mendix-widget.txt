Directory structure:
└── niallpg-react-arcgis-mendix-widget/
    ├── README.md
    ├── LICENSE
    ├── package.json
    ├── prettier.config.js
    ├── rollup.config.json
    ├── tsconfig.json
    ├── webpack.config.dev.js
    ├── .eslintrc.js
    ├── .prettierignore
    ├── src/
    │   ├── package.xml
    │   ├── ReactArcGIS.editorPreview.tsx
    │   ├── ReactArcGIS.tsx
    │   ├── ReactArcGIS.xml
    │   ├── components/
    │   │   ├── ArcGISContainer.tsx
    │   │   └── CustomPopup.tsx
    │   ├── ui/
    │   │   └── ReactArcGIS.css
    │   └── utils/
    │       ├── CustomStylingUtils.tsx
    │       ├── PopupUtils.tsx
    │       └── Utils.tsx
    └── typings/
        └── ReactArcGISProps.d.ts

================================================
FILE: README.md
================================================
## ReactArcGIS
New ArcGIS widget based on React, the Mendix Pluggable Widgets API and the newest ArcGIS API (4.22 / 02-2022)

## Features
v1.0.0

1. Static (in widget settings) as well as dynamic (front end, in app) loading of layers
2. Optional custom markers for each layer
3. Optional marker clustering per layer
4. Fully configurable pop-up windows per layer with both attributes from Mendix as well as ArcGIS
5. Three types of add on widgets:
	- Toggle layers pane (disable/enable layers by users)
	- Search widget; let an end user search on location
	- Legend: a legend entry for each layer. Also works with custom markers
	
v1.1.0
1. Added BaseMap Toggle functionality
2. Added Mendix default progress modal for when layers are loading
	

## Usage
If visualization of Mendix data on an ArcGIS map is needed

## Demo project
https://arcgisreactdemoproject-sandbox.mxapps.io/

## Issues, suggestions and feature requests
• Doesn't include drawing 
• No ArcGIS authentication

## Development and contribution
Feel free to contact me in case of questions. See the 'About' page in the demo project as well

## Project Structure

### Source Files
- `src/` - Main source code directory
  - `components/` - React components (ArcGISContainer.tsx, CustomPopup.tsx)
  - `ui/` - UI styling files (ReactArcGIS.css)
  - `utils/` - Utility functions (Utils.tsx, CustomStylingUtils.tsx, PopupUtils.tsx)
  - `ReactArcGIS.tsx` - Main widget component
  - `ReactArcGIS.xml` - Widget configuration
  - `package.xml` - Package metadata
  - `ReactArcGIS.editorPreview.tsx` - Editor preview component

### Type Definitions
- `typings/` - TypeScript type definitions
  - `ReactArcGISProps.d.ts` - Widget props interface

### Configuration Files
- `package.json` - Node.js dependencies and scripts
- `tsconfig.json` - TypeScript configuration
- `rollup.config.json` - Rollup bundler configuration
- `webpack.config.dev.js` - Webpack development configuration
- `prettier.config.js` - Prettier code formatting configuration
- `.eslintrc.js` - ESLint linting configuration
- `.gitattributes` - Git attributes for line endings
- `.gitignore` - Git ignore patterns
- `.prettierignore` - Prettier ignore patterns

### Assets Folder (Not Included in Git Ingest - Too Large)

The `assets/` folder contains the complete ArcGIS API for JavaScript 4.22 distribution and is too large for git ingest. It includes:

#### Custom Assets
- `custom/loading.gif` - Custom loading animation

#### ESRI ArcGIS API Assets
- `esri/core/` - Core ArcGIS API libraries and WebAssembly files
  - `libs/` - Core libraries (libtess.wasm)
  - `workers/` - Web workers for background processing
  - `t9n/` - Internationalization files (40+ language files)

- `esri/css/` - ArcGIS API stylesheets
  - `main.css`, `main.scss`, `view.css`

- `esri/geometry/` - Geometry processing
  - `support/` - WebAssembly files for geometry operations

- `esri/identity/` - Authentication and identity management
  - `t9n/` - Internationalization files for identity features

- `esri/images/` - ArcGIS API images and icons
  - `basemap/` - Basemap preview images
  - `Legend/` - Legend symbols
  - `materials/` - 3D material textures
  - `portal/` - Portal interface icons
  - `search/` - Search interface icons
  - `shared/` - Shared UI elements
  - `support/` - Support images and icons

- `esri/libs/` - Additional libraries
  - `basisu/` - Texture compression (basis_transcoder.wasm)
  - `i3s/` - Indexed 3D Scene layers (i3s.wasm)
  - `linkchartlayout/` - Link chart layout (lclayout.wasm)
  - `vxl/` - Voxel layer support (vxlLayer.wasm)

- `esri/smartMapping/` - Smart mapping features
  - `t9n/` - Internationalization files for smart mapping

- `esri/symbols/` - Symbol definitions
  - `patterns/` - Pattern fill symbols

- `esri/t9n/` - Main internationalization files
  - 80+ language files for various ArcGIS features

- `esri/themes/` - ArcGIS themes and styling
  - `base/` - Base theme with colors, fonts, icons
  - `light/` - Light theme stylesheets

- `esri/views/` - Map view components
  - `3d/` - 3D view resources and environment
  - `magnifier/` - Magnifier tool resources

- `esri/widgets/` - ArcGIS widgets
  - 50+ widget directories including:
    - AreaMeasurement2D/3D
    - BasemapGallery/Toggle
    - Bookmarks, Compass, Directions
    - Editor, Feature, Legend
    - Popup, Search, Zoom
    - And many more specialized widgets
  - Each widget includes `t9n/` directories with 40+ language files

**Total Size**: The assets folder contains thousands of files including:
- 150+ JavaScript worker files
- 40+ language files per feature (2000+ total language files)
- WebAssembly files for geometry processing
- Hundreds of images and icons
- Complete theme system with fonts and styling
- Full widget library with internationalization

This comprehensive asset collection provides the complete ArcGIS API for JavaScript 4.22 runtime environment needed for the React widget to function properly.



================================================
FILE: LICENSE
================================================
The Apache License v2.0

Copyright Apache V2

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.



================================================
FILE: package.json
================================================
{
  "name": "reactarcgis",
  "widgetName": "ReactArcGIS",
  "version": "1.0.0",
  "description": "a sophisticated React widget integrating with the newest ArcGIS API 4.2.x",
  "copyright": "Apache V2",
  "author": "Ivo Sturm",
  "config": {
    "projectPath": "../..//",
    "mendixHost": "http://localhost:8080",
    "developmentPort": "3000"
  },
  "packagePath": "valcon",
  "scripts": {
    "start": "pluggable-widgets-tools start:server --open",
    "dev": "pluggable-widgets-tools start:web",
    "build": "pluggable-widgets-tools build:web",
    "lint": "pluggable-widgets-tools lint",
    "lint:fix": "pluggable-widgets-tools lint:fix",
    "prerelease": "npm run lint",
    "release": "pluggable-widgets-tools release:web"
  },
  "license": "Apache-2.0",
  "devDependencies": {
    "@arcgis/webpack-plugin": "^4.18.0",
    "@mendix/pluggable-widgets-tools": "^8.18.4",
    "@types/big.js": "^4.0.5",
    "@types/classnames": "^2.2.4",
    "@types/react": "~16.9.0",
    "@types/react-dom": "~16.9.0",
    "copy-webpack-plugin": "^6.2.1",
    "file-loader": "^6.2.0",
    "mendix-client": "^7.15.8",
    "webpack": "^5.65.0",
    "webpack-cli": "^4.9.1",
    "webpack-merge": "^5.8.0"
  },
  "dependencies": {
    "@arcgis/core": "^4.22.2",
    "build": "^0.1.4",
    "classnames": "^2.2.6",
    "i": "^0.3.7"
  }
}



================================================
FILE: prettier.config.js
================================================
const base = require("@mendix/pluggable-widgets-tools/configs/prettier.base.json");

module.exports = {
    ...base
};



================================================
FILE: rollup.config.json
================================================
{
	preventAssignment: true
}


================================================
FILE: tsconfig.json
================================================
{
  "extends": "./node_modules/@mendix/pluggable-widgets-tools/configs/tsconfig.base.json",
	"compilerOptions": {
		"jsx": "react",
		"types": [ "mendix-client" ],
		"lib": [      
			"es2017",
			"dom"
		]		
    }

}


================================================
FILE: webpack.config.dev.js
================================================
const { merge } = require("webpack-merge");
const baseConfig = require("./node_modules/@mendix/pluggable-widgets-tools/configs/webpack.config.dev.js"); //Can also be webpack.config.prod.js
const CopyWebpackPlugin = require("copy-webpack-plugin");
const ArcGISPlugin = require("@arcgis/webpack-plugin");


const customConfig = {
    plugins: [
        new ArcGISPlugin({
            features: {
                "3d": false
              },
            }),
        new CopyWebpackPlugin({
            patterns: [
                {from: './assets', to:'./widgets/valcon/reactarcgis/assets'}
            ]
        })
    ],
    module: {
        rules: [
          {
            test: /\.(png|jpe?g|gif)$/i,
            use: [
              {
                loader: 'file-loader',
              },
            ],
          },
        ],
      },
    
};
const previewConfig = {

};

module.exports = [merge(baseConfig[0], customConfig), merge(baseConfig[1], previewConfig)];


================================================
FILE: .eslintrc.js
================================================
const base = require("@mendix/pluggable-widgets-tools/configs/eslint.ts.base.json");

module.exports = {
    ...base
};



================================================
FILE: .prettierignore
================================================
../



================================================
FILE: src/package.xml
================================================
<?xml version="1.0" encoding="utf-8" ?>
<package xmlns="http://www.mendix.com/package/1.0/">
    <clientModule name="ReactArcGIS" version="1.2.2" xmlns="http://www.mendix.com/clientModule/1.0/">
        <widgetFiles>
            <widgetFile path="ReactArcGIS.xml"/>
        </widgetFiles>
        <files>
            <file path="valcon/reactarcgis"/>
        </files>
    </clientModule>
</package>



================================================
FILE: src/ReactArcGIS.editorPreview.tsx
================================================
[Empty file]


================================================
FILE: src/ReactArcGIS.tsx
================================================
import { Component, ReactNode, createElement } from "react";
import { ValueStatus } from "mendix";
import ArcGISContainer from "./components/ArcGISContainer";
import esriConfig from "@arcgis/core/config.js";

import { ReactArcGISContainerProps } from "../typings/ReactArcGISProps";

import "./ui/ReactArcGIS.css";
import MapView from "@arcgis/core/views/MapView";
import Legend from "@arcgis/core/widgets/Legend";

export type position =
    | "bottom-leading"
    | "bottom-left"
    | "bottom-right"
    | "bottom-trailing"
    | "top-leading"
    | "top-left"
    | "top-right"
    | "top-trailing"
    | "manual";

export const logNode = "React ArcGIS Widget: ";

interface ArcGISContainerProps extends ReactArcGISContainerProps {
    gisObjects: GisObject[];
}

interface ArcGISContainerState {
    isLoaded: boolean;
    view: MapView;
    legend: Legend;
}

// ID field can either be client specific ID (if filled in) or ObjectId
export interface GisObject {
    mxGuid: any;
    ID: number | string;
    layerID: string;
    color: string;
    size: number;
    symbol: string;
    center: number[];
    query: string;
}

export default class ReactArcGIS extends Component<ArcGISContainerProps, ArcGISContainerState> {
    constructor(props: ArcGISContainerProps) {
        super(props);
        this.state = { isLoaded: false, view: {} as MapView, legend: {} as Legend };
    }
    shouldComponentUpdate(nextProps: ArcGISContainerProps, nextState: ArcGISContainerState): boolean {
        // no changes, no reload!
        if (nextState === this.state && nextProps === this.props) {
            console.debug(logNode + "state nor props changed! No rerendering...");
            return false;
        } // props changes, reload only if all configured objects are actually available!
        else if (nextState === this.state && nextProps !== this.props) {
            if (
                ((nextProps.graphicObjects?.status === "available" && nextProps.graphicObjects?.items) ||
                    !nextProps.graphicObjects) &&
                ((nextProps.dynLayerObject?.status === "available" && nextProps.dynLayerObject?.items) ||
                    !nextProps.dynLayerObject)
            ) {
                let nextPropsStatusItemsLength = 0;
                if (nextProps.graphicObjects?.items && nextProps.graphicObjects?.items.length) {
                    nextPropsStatusItemsLength = nextProps.graphicObjects?.items.length;
                }
                let prevPropsStatusItemsLength = 0;
                if (this.props.graphicObjects?.items && this.props.graphicObjects?.items.length) {
                    prevPropsStatusItemsLength = this.props.graphicObjects?.items.length;
                }
                const messagePrefix = "props changed, all configured objects now available! Map loaded (" + this.state.isLoaded + ") GraphicObjects amount (" + prevPropsStatusItemsLength + ") + status (" + nextProps.graphicObjects?.status + ")";
                if (this.state.isLoaded  && 
                    nextProps.graphicObjects?.status === ValueStatus.Available && this.props.graphicObjects?.status === ValueStatus.Available &&
                    prevPropsStatusItemsLength > 0 && nextPropsStatusItemsLength > 0 &&
                    prevPropsStatusItemsLength === nextPropsStatusItemsLength) {
                    if (prevPropsStatusItemsLength === 1 &&
                        nextPropsStatusItemsLength === 1 &&
                        (nextProps.graphicObjects.items && this.props.graphicObjects.items) &&
                        nextProps.graphicObjects?.items[0].id !== this.props.graphicObjects?.items[0].id
                        ) {
                            console.debug(logNode + messagePrefix + " didn't change, but Mendix ID changed. Rerendering...");
                            return true;               
                    } else // in case of unexpected reloads from Mendix or React framework, block if no changes
                    {
                            console.debug(logNode + messagePrefix + " didn't change. NOT rerendering...~"
                        );
                        return false;
                    }
                } else {
                        console.debug(logNode + messagePrefix + " changed. Rerendering... ");
                        return true;
                }
            } else {
                console.debug(
                    logNode + "props changed, one, multiple or all configured objects not available yet. Waiting..."
                );
                return false;
            }
        } // state changed, don't reload if only map was added to state!
        else if (nextState !== this.state && nextProps === this.props) {
            if (!this.state.isLoaded && nextState.isLoaded) {
                console.debug(logNode + "state isLoaded changed!");
                return false;
            } else {
                console.debug(logNode + "state changed!");
                return true;
            }
        } else if (nextState !== this.state && nextProps !== this.props) {
            console.debug(logNode + "state and props changed!");
            return true;
        } // shouldn't occur
        else {
            return false;
        }
    }
    setLoaded(isLoaded: boolean, view: MapView, legend: Legend): void {
        console.debug(logNode + "setting isLoaded on widget to: " + isLoaded);
        this.setState({ isLoaded, view, legend });
    }
    mapPosition(positionSource: string): position {
        if (positionSource === "bottomLeft") {
            return "bottom-left";
        } else if (positionSource === "topLeft") {
            return "top-left";
        } else if (positionSource === "topRight") {
            return "top-right";
        } else if (positionSource === "bottomRight") {
            return "bottom-right";
        }
        return "bottom-right";
    }
    render(): ReactNode {
        // make known to esri where local assests / js files are stored
        esriConfig.assetsPath = "./widgets/valcon/reactarcgis/assets";
        const legendPosition = this.mapPosition(this.props.legendPosition);
        const searchPosition = this.mapPosition(this.props.searchPosition);
        const toggleLayerPosition = this.mapPosition(this.props.toggleLayerPosition);
        const bmTogglePosition = this.mapPosition(this.props.bmTogglePosition);
        const datasource = this.props.graphicObjects;
        const dynLayerSource = this.props.dynLayerObject;

        // show loading div if objects are still loading hence not available yet
        if (!datasource || datasource.status !== ValueStatus.Available || !datasource.items) {
            if (datasource?.status !== ValueStatus.Unavailable) {
                return <div>Loading...</div>;
            }
        }

        if (dynLayerSource) {
            if (dynLayerSource.status !== ValueStatus.Available || !dynLayerSource.items) {
                if (dynLayerSource?.status !== ValueStatus.Unavailable) {
                    return <div>Loading...</div>;
                }
            }
        }

        return (
            <div>
                <ArcGISContainer
                    onLoad={(isLoaded: boolean, view: MapView, legend: Legend) => {
                        this.setLoaded(isLoaded, view, legend);
                    }}
                    mapHeight={this.props.mapHeight}
                    mapWidth={this.props.mapWidth}
                    baseMapID={this.props.baseMapID}
                    bmToggleID={this.props.bmToggleID}
                    bmToggleEnabled={this.props.bmToggleEnabled}
                    bmTogglePosition={bmTogglePosition}
                    bmTogglePlaceHolderIndex={this.props.bmTogglePlaceHolderIndex}
                    defaultZoom={this.props.defaultZoom}
                    objectZoom={this.props.singleObjectZoom}
                    defaultLocation={[this.props.defaultX, this.props.defaultY]}
                    mxObjects={datasource}
                    objectIDAttr={this.props.objectIDAttr}
                    layerIDAttr={this.props.layerIDAttr}
                    colorAttr={this.props.colorAttr}
                    sizeAttr={this.props.sizeAttr}
                    symbolAttr={this.props.symbolAttr}
                    dsShowAllObjects={this.props.dsShowAllObjects}
                    dsHighlightingEnabled={this.props.dsHighlightingEnabled}
                    loadingBehavior={this.props.loadingBehavior}
                    loadingModalMessage={this.props.loadingModalMessage}
                    csDefaultArray={this.props.csDefaultArray}
                    csLegendEntriesArray={this.props.csLegendEntriesArray}
                    dynLayerObjects={dynLayerSource}
                    dynLayerLayerIDAttr={this.props.dynLayerLayerID}
                    dynLayerIndexAttr={this.props.dynLayerIndexAttr}
                    dynLayerServerTypeAttr={this.props.dynLayerServerTypeAttr}
                    dynLayerStaticURLAttr={this.props.dynLayerStaticURLAttr}
                    dynLayerObjectIDAttr={this.props.dynLayerObjectIDAttr}
                    dynLayerVisibilityOnLoadAttr={this.props.dynLayerVisibilityOnLoadAttr}
                    dynLayerCustomStylingEnabledAttr={this.props.dynLayerCustomStylingEnabledAttr}
                    dynLayerClusteringEnabledAttr={this.props.dynLayerEnableClusteringAttr}
                    dynLayerMendixObjectsAttr={this.props.dynLayerMendixObjectsAttr}
                    layerArray={this.props.layerArray}
                    intAttributesArray={this.props.intAttributesArray}
                    intMendixXPathStringr={this.props.intMendixXPathString}
                    intButtonAction={this.props.intButtonAction}
                    intButtonLabel={this.props.intButtonLabel}
                    intButtonClass={this.props.intButtonClass}
                    intButtonIcon={this.props.intButtonIcon}
                    cl_enabled={this.props.cl_enabled}
                    cl_popupTitle={this.props.cl_popupTitle}
                    cl_popupContent={this.props.cl_popupContent}
                    cl_radius={this.props.cl_radius}
                    cl_minSize={this.props.cl_minSize}
                    cl_maxSize={this.props.cl_maxSize}
                    cl_symbolTextColor={this.props.cl_symbolTextColor}
                    cl_symbolTextSize={this.props.cl_symbolTextSize}
                    legendEnabled={this.props.enableLegend}
                    legendStartExpanded={this.props.legendStartExpanded}
                    legendPosition={legendPosition}
                    legendPlaceHolderIndex={this.props.legendPlaceholderIndex}
                    legendTitle={this.props.legendTitle}
                    searchEnabled={this.props.enableSearch}
                    searchStartExpanded={this.props.searchStartExpanded}
                    searchPosition={searchPosition}
                    searchPlaceHolderIndex={this.props.searchPlaceholderIndex}
                    toggleLayerEnabled={this.props.enableToggleLayer}
                    toggleLayerStartExpanded={this.props.toggleLayerStartExpanded}
                    toggleLayerPosition={toggleLayerPosition}
                    toggleLayerPlaceHolderIndex={this.props.toggleLayerPlaceholderIndex}
                    authPortalURL={this.props.authPortalURL}
                    isLoaded={this.state.isLoaded}
                    view={this.state.view}
                    legend={this.state.legend}
                />
            </div>
        );
    }
}



================================================
FILE: src/ReactArcGIS.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<widget id="valcon.reactarcgis.ReactArcGIS" pluginWidget="true" needsEntityContext="true" offlineCapable="true"
        supportedPlatform="Web"
        xmlns="http://www.mendix.com/widget/1.0/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.mendix.com/widget/1.0/ ../node_modules/mendix/custom_widget.xsd">
    <name>React ArcGIS</name>
    <description>a sophisticated React widget integrating with the newest ArcGIS API 4.2.x</description>
    <icon>

/9j/4AAQSkZJRgABAQEAAQABAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAAXABcDAREA
AhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAACgkGB//EAB8QAAIDAQEBAAMBAAAAAAAAAAUGAwQH
AgEJCBIWFP/EABcBAQEBAQAAAAAAAAAAAAAAAAgHBgX/xAAkEQACAwEAAgICAgMAAAAAAAADBAEC
BQYHExEUABUIEhYXI//aAAwDAQACEQMRAD8As99DvqPLZv6PnuGFy7FczpstK38UpdmKdYv2iHwX
ehaJtrKLuL16nkZD9yaJm6GFa1arpdWk4vzGzF1X+SWreed6vOxuj5nFazWdc29oDUBnraYMgzpi
f29CCjRU9E92mr0t7JUzWoz1Kl0HiKLDgs4Ts+l0smgs7EogPTdCa0amx7bZWXEiLCxJRWvR7bdK
zUcUzE5HWA/3I2yD2LDPF+Ldvolmmu93hjINzwBoDnVq2JQflxDUkm6w2OYaQbotlw5T5GqBMhXg
HAVz/YZr0Tc8McM93gr73GkfIk+L/EPDF6nyTz3LpPauPq6OVwvNeRN/Y7yHsJIrBwc3VhZeu4iw
KoK7WgwjoZPOaEFcO5XLZqouXue8peT+g1f1Gf0W+xqYFJ0NDUN485hDjt/HYaF7oYWLqMaGZqYY
yGOuIL+U7vZFLUGlXQziMNoT+ef0o1Fyeb+JflNXCx14Z4gSptErABi88bvFUy7VFd65rBVGv6vO
qesNxvKtJlXAHRO+iPGcO1Tt3BiWB2LnE97hd/mRq4lG1aTHyXP0LAu6nb+1qEAYq0+k1gEr67mH
UdSVsE9RUGwOPxcc30uf0a1rqlj7IK0+2CaxSw7/ADI7zWkFN8UqWvxaJJaaewU/NqFFe5uhLcaE
bA3ohH33K89eslzV1cDxioIIMhWf3J1TNNrsL07faIgx9n13DMdUywNNcrYW7nBCoKXKHPEFihXs
cniTgbJ9f3pVc3o+sCTL57sA8zrdZ1KGIxZ3F1eYxs7Jrqq4CUPrP2Y6BlGuvsrN1RWQIENjycfJ
Oq2r3xmhLt9C9mPJZIefVN9PPR+2COg5LQ1CXoDR1G9IFtFRHMyLXQhjJLZzShuLo/nI3TZ8udlX
pa7yxg0Bztrsqc06UzE5jFrptGVeqAxwDn9MM2bs9Ur3GFbacQOoPFVRhGCtS89g88i76Pc/x/6L
zpmcz5M8W9l0DNuFytHP006jrbl+qNl6hH9WhOge6FHWE6XKggK5QsPQXAUiq5RItQzamP6Tyv8A
6960SW5t4fN5b5ktoeTSdC2qtltV+JGfG5jCdT+ako7nMl0ddc8GVYvWpIrWPzSZPPHrsOirKKhM
ayx6BiYavTBK/P6iDrkC1nMWut5RrLpK6Jr3A6tQ2CxTjt1RNquMtGo4+O5JrMXp28WcXu5OVubz
2mXWxh7VeeyHDUNYhdH6v7JpRllsAm5kWR+tZvapGBlKUHwSa1mIoHhjo2dXyN2uN/kud0KXNL2q
zUdXv2aZTuegYD2fzFL2CYVETyZV51Ylw0iJr8VmULfU/wCTsuhmSm6Zbz1yJFlmLTLFOh0vWC+U
uJm34fez0So2llpb1XHHkvDbcWlAtNyy457oBdtd83nb+XoskjbB9tJ3n9fmNzPvqZTyr186Qt2z
38LaYAMQ9bOeEO5fWSoBg0s0kym6tNyRUT4wNVrfdcDTqBsu5bY8XfZy/wBE7pUoUZdTn5KZicYr
y0w5mFA0azuVtI0M3ntxITLv5DT+YyWoeoMOh6RWJM+kg1E0Wc1NFalYHWZSzbzUmrUOBTZQu2Vr
hQI9Cq5GLmyK9cF0h0O46oRXyE9GrZuWLxH3fF+MfHOLxqz+4oK+bsZPY87ymYokxuX0DbDAt4/Q
7N3F40LxpUymg56Ofa2H6A2dObPBSTAz/F7rWs0mHrC5vqf15Ctc/wBv1rbn0lo0Srj1sEfI4Vlm
BoysOWxmd0NBaehXabXzkU9c3rY58nvmgQ/F4CA0fVh/dF2G1z06euEji+2nRpVn7KjSejMpsDS7
FhDhdGuU1RdzNZZ3VVz8Ncbb0rq4tD2ZvCoGmvRBSUFrlhL7ZXaAtb4HVgq6qdj+qsyKh7popANc
cf8ASFx/Mz8R+KvhPH+Dwijv6xNCuttSgx0Wqkl9GNZxBESIL1W9zH1lADpf6q0FvNKltYxDHtYs
/wD/2Q==
	
	</icon>
    <properties>
        <propertyGroup caption="Appearance">
            <propertyGroup caption="Size">
                <property key="mapHeight" type="integer" defaultValue="600">
                    <caption>Height</caption>
                    <description>The map's height in pixels. Setting it to 10.000 will set it to 100 of the view height and resize it dynamically when zooming.</description> 
                </property>
                <property key="mapWidth" type="integer" defaultValue="900">
                    <caption>Width</caption>
                    <description>The map's width in pixels. Setting it to 10.000 will set it to 100 % of the width of the screen and will resize it dynamically when zooming.</description> 
                </property>
            </propertyGroup>
            <propertyGroup caption="Basemaps">
                <property key="baseMapID" type="string" required="false" defaultValue="topo-vector">
                    <caption>Base Default Map</caption>
                    <description>Default map is "topo-vector". Pick one of the values as published by Esri: https://developers.arcgis.com/javascript/latest/api-reference/esri-Map.html#basemap</description>
                </property>	
                <property key="bmToggleEnabled" type="boolean" defaultValue="true">
                    <caption>Enable BaseMap Toggle</caption>
                    <description>Whether a Base Map Toggle will be added to the map</description> 
                </property> 
                <property key="bmToggleID" type="string" required="false" defaultValue="satellite">
                    <caption>Base Toggle Map</caption>
                    <description>Only used if BaseMap Toggle enabled in 'Widgets' tab. Default map to toggle is "satellite". Pick one of the values as published by Esri: https://developers.arcgis.com/javascript/latest/api-reference/esri-Map.html#basemap</description>
                </property>	
                <property key="bmTogglePosition" type="enumeration" required="true" defaultValue="topRight">
                    <caption>Position</caption>
                    <description>Determine where the widget should be position on the map.</description>
                    <enumerationValues>
                        <enumerationValue key="bottomRight">Bottom Right</enumerationValue>
                        <enumerationValue key="bottomLeft">Bottom Left</enumerationValue>
                        <enumerationValue key="topRight">Top Right</enumerationValue>
                        <enumerationValue key="topLeft">Top Left</enumerationValue>
                    </enumerationValues>
                </property>
                <property key="bmTogglePlaceHolderIndex" type="integer" defaultValue="1">
                    <caption>Placeholder Index</caption>
                    <description>If more widgets, like Legend, have same location selected, use this attribute to make it appear first (1) or second (2).</description> 
                </property>
            </propertyGroup>
             <propertyGroup caption="Default Location / Zooming">
                <property key="defaultY" type="integer" defaultValue="52">
                    <caption>Default Y</caption>
                    <description>Default Y location for the map to start at.</description> 
                </property>
                <property key="defaultX" type="integer" defaultValue="4">
                    <caption>Default X</caption>
                    <description>Default X for the map to start at.</description> 
                </property>
                <property key="defaultZoom" type="integer" defaultValue="3">
                    <caption>Default Zoom Level</caption>
                    <description>The zoom level used when displaying a map only.</description> 
                </property>
                <property key="singleObjectZoom" type="integer" defaultValue="6">
                    <caption>Object Zoom Level</caption>
                    <description>The zoom level used when focussing on an object.</description> 
                </property>
             </propertyGroup>
        </propertyGroup>
        <propertyGroup caption="Data Source">
            <propertyGroup caption="Graphic">
				<property key="graphicObjects" type="datasource" isList="true" required="false">
					<caption>Data source</caption>
					<description/>
				</property>
				<property key="objectIDAttr" type="attribute" required="true" dataSource="graphicObjects">
					<caption>Object Identifier attribute</caption>
					<description>The unique object identifier. Can either be the actual Esri ID (ObjectId) or some other supposed to be unique field. If it is not the Esri ID, then in your layer configurations, also add the settings Client ID and Client ID Attribute Type</description>
					<attributeTypes>
						<attributeType name="Integer"/>
                        <attributeType name="Long"/>
                        <attributeType name="String"/>
					</attributeTypes>
				</property>
				<property key="layerIDAttr" type="attribute" required="true" dataSource="graphicObjects">
					<caption>Layer ID attribute</caption>
					<description>The unique layer id the object is stored in.</description>
					<attributeTypes>
						<attributeType name="Integer"/>
                        <attributeType name="String"/>
					</attributeTypes>
				</property>
				<property key="colorAttr" type="attribute" required="false" dataSource="graphicObjects">
					<caption>Color attribute</caption>
					<description>The attribute determining the Color of the object. Is used to overrule default colors from ArcGIS.</description>
					<attributeTypes>
						<attributeType name="String"/>
					</attributeTypes>
				</property>
				<property key="sizeAttr" type="attribute" required="false" dataSource="graphicObjects">
					<caption>Size attribute</caption>
					<description>The attribute determining the Size of the object. Is used to overrule default colors from ArcGIS. 4 is small, 50 very large.</description>
					<attributeTypes>
						<attributeType name="Integer"/>
					</attributeTypes>
				</property>
				<property key="symbolAttr" type="attribute" required="false" dataSource="graphicObjects">
					<caption>Symbol attribute</caption>
					<description>The attribute determining the Symbol of the object. Is used to overrule default symbol from ArcGIS.</description>
					<attributeTypes>
						<attributeType name="Enum"/>
					</attributeTypes>
				</property>
            </propertyGroup> 
            <propertyGroup caption="Appearance">
				<property key="dsShowAllObjects" type="boolean" required="true" defaultValue="false">
					<caption>Show all ArcGIS Objects</caption>
					<description>If enabled all objects in layers will be shown and objects fed from this data source highlighted. If disabled only the objects fed from this data source are shown.
					</description>
				</property>
            	<property key="dsHighlightingEnabled" type="boolean" required="true" defaultValue="true">
					<caption>Highlight Mendix Objects</caption>
					<description>If enabled all available Mendix objects in datasource will be hightlighted with bright blue color.
					</description>
				</property>
            </propertyGroup>
            <propertyGroup caption="Loading behavior">
                <property key="loadingBehavior" type="enumeration" defaultValue="modal">
                        <caption>Loading Behavior</caption>
                        <description>Determine what loading feedback the widget should give during loading of the map.</description> 
                        <enumerationValues>
                            <enumerationValue key="modal">Modal</enumerationValue>
                            <enumerationValue key="animatedGIF">Animated GIF</enumerationValue>
                            <enumerationValue key="none">None</enumerationValue>
                    </enumerationValues>
                </property>
                <property key="loadingModalMessage" type="string" defaultValue="Loading layers...">
                        <caption>Modal Message</caption>
                        <description>Determine the progress message on the blocking modal if enabled.</description> 
                </property>
            </propertyGroup> 
        </propertyGroup>     
        <propertyGroup caption="Widgets">
            <propertyGroup caption="Legend">
                <property key="enableLegend" type="boolean" defaultValue="true">
                    <caption>Enable</caption>
                    <description>This decides whether a legend is available for the plotted layers.</description> 
                </property>
                <property key="legendStartExpanded" type="boolean" defaultValue="false">
                    <caption>Start Expanded</caption>
                    <description>This decides whether the legend is expanded on first load of map.</description> 
                </property>
                <property key="legendTitle" type="string" defaultValue="Legend">
                    <caption>Title</caption>
                    <description>The title to appear in the legend.</description> 
                </property>  
                <property key="legendPosition" type="enumeration" required="true" defaultValue="bottomRight">
                    <caption>Position</caption>
                    <description>Determine where the widget should be position on the map.</description>
                    <enumerationValues>
                        <enumerationValue key="bottomRight">Bottom Right</enumerationValue>
                        <enumerationValue key="bottomLeft">Bottom Left</enumerationValue>
                        <enumerationValue key="topRight">Top Right</enumerationValue>
                        <enumerationValue key="topLeft">Top Left</enumerationValue>
                    </enumerationValues>
                </property>
                <property key="legendPlaceholderIndex" type="integer" defaultValue="1">
                    <caption>Placeholder Index</caption>
                    <description>If more widgets, like Search, have same location selected, use this attribute to make it appear first (1) or second (2).</description> 
                </property>
            </propertyGroup>
            <propertyGroup caption="Search">
                <property key="enableSearch" type="boolean" defaultValue="true">
                    <caption>Enable Search</caption>
                    <description>Whether a Search Bar will be added to the map to search for and zoom to a typed in address.</description> 
                </property> 
                <property key="searchStartExpanded" type="boolean" defaultValue="false">
                    <caption>Start Expanded</caption>
                    <description>This decides whether the search box is expanded on first load of map.</description> 
                </property>
                <property key="searchPosition" type="enumeration" required="true" defaultValue="topRight">
                    <caption>Position</caption>
                    <description>Determine where the widget should be position on the map.</description>
                    <enumerationValues>
                        <enumerationValue key="bottomRight">Bottom Right</enumerationValue>
                        <enumerationValue key="bottomLeft">Bottom Left</enumerationValue>
                        <enumerationValue key="topRight">Top Right</enumerationValue>
                        <enumerationValue key="topLeft">Top Left</enumerationValue>
                    </enumerationValues>
                </property>
                <property key="searchPlaceholderIndex" type="integer" defaultValue="1">
                    <caption>Placeholder Index</caption>
                    <description>If more widgets, like Legend, have same location selected, use this attribute to make it appear first (1) or second (2).</description> 
                </property>
            </propertyGroup>
            <propertyGroup caption="Toggle Layers">
                <property key="enableToggleLayer" type="boolean" defaultValue="true">
                    <caption>Enable Toggle Layer</caption>
                    <description>Whether a Toggle Layer will be added to the map to toggle visibility of graphics within the layer.</description> 
                </property> 
                <property key="toggleLayerStartExpanded" type="boolean" defaultValue="false">
                    <caption>Start Expanded</caption>
                    <description>This decides whether the toggle layer list is expanded on first load of map.</description> 
                </property>
                <property key="toggleLayerPosition" type="enumeration" required="true" defaultValue="topRight">
                    <caption>Position</caption>
                    <description>Determine where the widget should be position on the map.</description>
                    <enumerationValues>
                        <enumerationValue key="bottomRight">Bottom Right</enumerationValue>
                        <enumerationValue key="bottomLeft">Bottom Left</enumerationValue>
                        <enumerationValue key="topRight">Top Right</enumerationValue>
                        <enumerationValue key="topLeft">Top Left</enumerationValue>
                    </enumerationValues>
                </property>
                <property key="toggleLayerPlaceholderIndex" type="integer" defaultValue="2">
                    <caption>Placeholder Index</caption>
                    <description>If more widgets, like Legend, have same location selected, use this attribute to make it appear first (1) or second (2).</description> 
                </property>
            </propertyGroup>
        </propertyGroup>
        <propertyGroup caption="Layers">
            <propertyGroup caption="Static Layers">
                <property key="layerArray" type="object" isList="true" required="false">
                <caption>Layer Definitions</caption>
                <description>Add one or multiple layers to plot on the basemap.</description>
                <properties>
                    <propertyGroup caption="Layer Entries">
                        <propertyGroup caption="Definition">
                            <property key="layerServerType" type="enumeration" required="true" defaultValue="FeatureServer">
                                <caption>Layer Server Type</caption>
                                <description>Determines which layer server type to use. Preferred is FeatureServer. Currently actually a MapServer can be chosen but it will be loaded as FeatureServer. A PortalItem is a customized map by a client based on a actual FeatureServer. It has a unique id which can be entered below.</description>
                                <enumerationValues>
                                    <enumerationValue key="MapServer">MapServer</enumerationValue>
                                    <enumerationValue key="FeatureServer">FeatureServer</enumerationValue>
                                    <enumerationValue key="PortalItem">PortalItem</enumerationValue>
                                </enumerationValues>
                            </property>
                            <property key="layerURLStatic" type="string">
                                <caption>Static Layer URL</caption>
                                <description>Configure a static URL of the layer here.</description>
                            </property>
                            <property key="layerObjects" type="datasource" isList="true" required="false">
                                <caption>Dynamic Layer URL</caption>
                                <description>Layer URL dynamic source. If configured, overrules above possibly configured 'Static Layer URL' value.</description>
                            </property>
                            <property key="urlAttr" type="attribute" required="false" dataSource="layerObjects">
                                <caption>URL attribute</caption>
                                <description>The URL attribute for the layer.</description>
                                <attributeTypes>
                                    <attributeType name="String"/>
                                </attributeTypes>
                            </property>
                            <property key="layerID" type="string">
                                <caption>Layer ID</caption>
                                <description>The name/identifier of the layer to appear in the toggle layers pane.  Should correspond with Layer ID attribute of Mendix object if used.</description>
                            </property>
                            <property key="layerIndex" type="integer" defaultValue="1">
                                <caption>Layer Index</caption>
                                <description>Determine the order in which to load the layer. Higher order means loaded 'later'/on top.</description>
                            </property>
                            <property key="objectIDAttr" type="string" required="true" defaultValue="ObjectId">
                                <caption>Object ID</caption>
                                <description>The esri Field storing the unique identifier of the object. Look it up in the layer definition of ArcGIS, field which has type: esriFieldTypeOID. Value is case sensitive</description>
                            </property>
                            <property key="clientIDAttr" type="string" required="false" defaultValue="">
                                <caption>Client ID</caption>
                                <description>(Optional) The client/customer ID attribute, which can be used next to the Object ID. Needs to be stored on the ArcGIS side as well.</description>
                            </property>
                            <property key="clientIDAttrType" type="enumeration" defaultValue="String">
                                <caption>Client ID Attr Type</caption>
                                <description>The client/customer ID attribute type</description>
                                <enumerationValues>
                                    <enumerationValue key="String">String</enumerationValue>
                                    <enumerationValue key="Number">Number</enumerationValue>
                                </enumerationValues>
                            </property>
                            <property key="featureLayerID" type="string" required="false">
                                <caption>Feature Layer ID</caption>
                                <description>(FeatureLayer only) The ID of the FeatureLayer.</description>
                            </property>
                            <property key="mendixLayer" type="boolean" required="true" defaultValue="false">
                                <caption>Mendix Layer</caption>
                                <description> One Feature Layer can be connected to Mendix Objects. This layer will also be used for sketching if enabled. See own Sketch tab as well.</description>
                            </property>
                            <property key="portalItemID" type="string" required="false">
                                <caption>Portal Item ID</caption>
                                <description>(PortalItem only) The unique ID of a portal item. Typically looks like: aa1d3f80270146208328cf66d022e09c</description>
                            </property>
                        </propertyGroup> 
                    </propertyGroup>
                    <propertyGroup caption="Apearance">
                        <propertyGroup caption="Appearance">    
                            <property key="visibleLayerIndexes" type="string" required="false">
                                <caption>Visible Layer Indexes</caption>
                                <description>(MapLayer only) The indexes, concatenated and separated with a comma, of the Layers to show on the basemap. So, if you want to show layers 2 and 3, add 2, 3 here.</description>
                            </property>
                            <property key="visibilityOnLoad" type="boolean" required="true" defaultValue="true">
                                <caption>Visibility On Load</caption>
                                <description>If set to 'Yes' the layer starts with the layer ticked, hence visible.</description>
                            </property>
                            <property key="clusteringEnabled" type="boolean" required="true" defaultValue="false">
                                <caption>Clustering</caption>
                                <description>(Only applicable if clustering enabled) Determines for this layer whether to enable clustering. Advise only to use for point layers. </description>
                            </property>
                            <property key="customStylingEnabled" type="boolean" required="true" defaultValue="false">
                                <caption>Custom Styling</caption>
                                <description>Whether to overrule styling for the objects in this layer. Will use color + type of GISObject + mapping of default color + type as defined for Layer ID in 'Custom Coloring'</description>
                            </property>
                            <property key="showAttribution" type="boolean" defaultValue="false">
                                <caption>Show Attribution</caption>
                                <description>Whether to show the attribution (who contributed to the map ESRI, Nasa, Kadaster, etc) of the Layer or not.</description>
                            </property>
                            <property key="opacity" type="string" required="false" defaultValue="1.0">
                                <caption>Layer Opacity</caption>
                                <description>(FeatureLayer only) Adjust the opacity of the objects plotted on the map. 1.0 is fully opaque, 0.0 is fully transparent. For polyons typically use 0.5.</description>
                            </property>
                        </propertyGroup> 
                    </propertyGroup>
                </properties>
                </property>
            </propertyGroup>
            <propertyGroup caption="Dynamic Layers">
                <property key="dynLayerObject" type="datasource" isList="true" required="false">
                    <caption>Dynamic Layer Data source</caption>
                    <description>Load the main client layer as a static layer, perhaps adding the Client ID for quering and use this data source to add specific other supporting layers not being the main layer.</description>
                </property>
                <property key="dynLayerLayerID" type="attribute" required="false" dataSource="dynLayerObject">
                    <caption>Layer ID Attr</caption>
                    <description>The name/identifier of the layer to appear in the toggle layers pane. Should correspond with Layer ID attribute of Mendix object if used. For a PortalItem enter the portal item id here. See static layer config for an example.</description>
                    <attributeTypes>
                        <attributeType name="String"/>
                    </attributeTypes>
                </property>
                <property key="dynLayerServerTypeAttr" type="attribute" required="false" dataSource="dynLayerObject">
                    <caption>Layer Server Type Attr</caption>
                    <description>Determines which layer server type to use. Preferred is FeatureServer</description>
                    <attributeTypes>
                        <attributeType name="Enum"/>
                    </attributeTypes>
                </property>
                <property key="dynLayerVisibilityOnLoadAttr" type="attribute" required="false" dataSource="dynLayerObject">
                    <caption>Visibility On Load</caption>
                    <description>Determines the visibility of the layer once the map loads the first time.</description>
                    <attributeTypes>
                        <attributeType name="Boolean"/>
                    </attributeTypes>
                </property>
                <property key="dynLayerEnableClusteringAttr" type="attribute" required="false" dataSource="dynLayerObject">
                    <caption>Clustering Enabled</caption>
                    <description>(Only applicable if clustering enabled) Determines for this layer whether to enable clustering. Advise only to use for point layers.</description>
                    <attributeTypes>
                        <attributeType name="Boolean"/>
                    </attributeTypes>
                </property>
                <property key="dynLayerCustomStylingEnabledAttr" type="attribute" required="false" dataSource="dynLayerObject">
                    <caption>Custom Styling Enabled</caption>
                    <description>Whether to overrule styling for the objects in this layer. Will use mapping as defined for Layer ID in 'Custom Coloring'</description>
                    <attributeTypes>
                        <attributeType name="Boolean"/>
                    </attributeTypes>
                </property>
                <property key="dynLayerStaticURLAttr" type="attribute" required="false" dataSource="dynLayerObject">
                    <caption>URL Attr</caption>
                    <description>The static layer URL</description>
                    <attributeTypes>
                        <attributeType name="String"/>
                    </attributeTypes>
                </property>
                <property key="dynLayerObjectIDAttr" type="attribute" required="false" dataSource="dynLayerObject">
                    <caption>Object ID Attr</caption>
                    <description>The esri Field storing the unique identifier of the object. Look it up in the layer definition of ArcGIS, field which has type: esriFieldTypeOID. Value is case sensitive</description>
                    <attributeTypes>
                        <attributeType name="String"/>
                    </attributeTypes>
                </property>
                <property key="dynLayerIndexAttr" type="attribute" required="false" dataSource="dynLayerObject">
                    <caption>Index Attr</caption>
                    <description>Determine the order in which to load the layer. Higher order means loaded 'later'/on top.</description>
                    <attributeTypes>
                        <attributeType name="Integer"/>
                    </attributeTypes>
                </property>
                <property key="dynLayerMendixObjectsAttr" type="attribute" required="false" dataSource="dynLayerObject">
                    <caption>Mendix Objects Attr</caption>
                    <description>The ONE Feature Layer which can be connected to Mendix objects. If sketching is enabled, this layer will be used.</description>
                    <attributeTypes>
                        <attributeType name="Boolean"/>
                    </attributeTypes>
                </property>
            </propertyGroup>
        </propertyGroup>
        <propertyGroup caption="Custom Styling">
            <propertyGroup caption="Default Styling for MendixLayers">
                <property key="csDefaultArray" type="object" isList="true" required="false">
                    <caption>Default Custom Styling</caption>
                    <description>(MendixLayer only) Add default appearance to the GISObjects.</description>
                    <properties>
                        <propertyGroup caption="Default Styling Entries">
                            <propertyGroup caption="Default Mapping">
                                <property key="csDefaultArrayLayerID" type="string" required="false" defaultValue="fill with Layer ID!">
                                    <caption>Layer ID</caption>
                                    <description>(MendixLayer only) the Layer ID to apply the mapping to as used in static/dynamic layer config.</description>
                                </property>
                                <property key="csDefaultArrayColor" type="string" required="false" defaultValue="#FF0000">
                                    <caption>Default Color</caption>
                                    <description>The default color for all objects in the Mendix Layer that are not stored in Mendix. If left empty will leave color as is. Can be hexadecimal #FF0000 or RGB: 255,0,0</description> 
                                </property>
                                <property key="csDefaultArraySize" type="integer" required="true" defaultValue="8">
                                    <caption>Default Size</caption>
                                    <description>The default size for all objects in the Mendix Layer that are not stored in Mendix. 4 is small, 50 is very large</description> 
                                </property>
                                <property key="csDefaultArraySymbol" type="enumeration" required="true" defaultValue="circle">
                                    <caption>Default Symbol</caption>
                                    <description>Determine the symbol for the graphic.</description>
                                    <enumerationValues>
                                        <enumerationValue key="circle">Circle</enumerationValue>
                                        <enumerationValue key="cross">Cross</enumerationValue>
                                        <enumerationValue key="diamond">Diamond</enumerationValue>
                                        <enumerationValue key="square">Square</enumerationValue>
                                        <enumerationValue key="x">X</enumerationValue>
                                    </enumerationValues>
                                </property>
                            </propertyGroup>
                        </propertyGroup>
                    </properties>
                </property>
            </propertyGroup>
            <propertyGroup caption="Legend Entries for MendixLayers">
                <property key="csLegendEntriesArray" type="object" isList="true" required="false">
                    <caption>Legend Entries</caption>
                    <description>(MendixLayer only) Add legend entries for custom styled GISObjects.</description>
                    <properties>
                        <propertyGroup caption="Default Styling Entries">
                            <propertyGroup caption="Default Mapping">
                                <property key="csLegendEntryLayerID" type="string" required="false" defaultValue="fill with Layer ID!">
                                    <caption>Layer ID</caption>
                                    <description>(MendixLayer only) the Layer ID to apply the mapping to as used in static/dynamic layer config.</description>
                                </property>
                                <property key="csLegendEntryName" type="string" required="false" defaultValue="Type 1">
                                    <caption>Name</caption>
                                    <description>The name of the legend entry to appear next to the symbol with set size and color.</description> 
                                </property>
                                <property key="csLegendEntryColor" type="string" required="false" defaultValue="#FF0000">
                                    <caption>Color</caption>
                                    <description>The color for the legend entry. Can be hexadecimal #FF0000 or RGB: 255,0,0</description> 
                                </property>
                                <property key="csLegendEntrySize" type="integer" required="true" defaultValue="8">
                                    <caption>Size</caption>
                                    <description>The size for the legend entry. 4 is small, 50 is very large</description> 
                                </property>
                                <property key="csLegendEntrySymbol" type="enumeration" required="true" defaultValue="circle">
                                    <caption>Symbol</caption>
                                    <description>Determine the symbol for the graphic of the legend entry</description>
                                    <enumerationValues>
                                        <enumerationValue key="circle">Circle</enumerationValue>
                                        <enumerationValue key="cross">Cross</enumerationValue>
                                        <enumerationValue key="diamond">Diamond</enumerationValue>
                                        <enumerationValue key="square">Square</enumerationValue>
                                        <enumerationValue key="x">X</enumerationValue>
                                    </enumerationValues>
                                </property>
                            </propertyGroup>
                        </propertyGroup>
                    </properties>
                </property>
            </propertyGroup>
        </propertyGroup>
        <propertyGroup caption="Interaction">
            <propertyGroup caption="Popup Attributes Config">
                <property key="intAttributesArray" type="object" isList="true" required="false">
                    <caption>Attributes Array</caption>
                    <description>Add one or multiple attributes to the pop-up of a configured layer.</description>
                    <properties>
                        <propertyGroup caption="Attribute Entries">
                            <property key="intAttributeName" type="string">
                                <caption>Attribute Name</caption>
                                <description>The name of the attribute in the layer to appear in the pop-up. Case sensitive and on ArcGIS side mostly defined as all uppercase.</description>
                            </property>
                            <property key="intAttributeMendix" type="boolean" defaultValue="false">
                                <caption>Mendix Owned</caption>
                                <description>If marked as a Mendix Owned label, based on this attribute name, the value will be retrieved from Mendix instead of ArcGIS.</description>
                            </property>
                            <property key="intAttributeLabel" type="string">
                                <caption>Attribute Label</caption>
                                <description>The label to appear next to the attribute value retrieve for 'Attribute Name'.</description>
                            </property>
                            <property key="intAttributeLayerID" type="string">
                                <caption>Layer ID</caption>
                                <description>The ID of the layer the attribute is stored in. This value needs to agree with a value configured in 'Layers' > 'Layer definitions' > 'Layer ID'.</description>
                            </property>
                            <property key="intAttributeIsTitle" type="boolean" defaultValue="false">
                                <caption>Is Title</caption>
                                <description>Determines whether to make this attribute available in the title of the pop-up.</description>
                            </property>
                            <property key="intAttributeDecimalPlaces" type="integer" defaultValue="0">
                                <caption>Decimals</caption>
                                <description>(Decimal field only) Determine the amount of decimals to appear.</description>
                            </property>
                            <property key="intAttributeDecimalSeparator" type="string" defaultValue=".">
                                <caption>Separator</caption>
                                <description>(Decimal field only) Determine the separator used for thousands</description>
                            </property>
                        </propertyGroup>     
                    </properties>                         
                </property>
                <property key="intMendixXPathString" type="string" defaultValue="ArcGIS.GISObject[ObjectID">
                    <caption>XPath String</caption>
                    <description>(Workaround) Here, add the XPath (without // prefix, but with Domain Model name) to the Esri (mostly ObjectId) stored on the Mendix object. Pluggable widgets API is lacking possibility to select a microflow only.</description>
                </property>              
            </propertyGroup>
            <propertyGroup caption="Popup Button">
                <property key="intButtonAction" type="action" required="false" dataSource="graphicObjects">
                    <caption>Action</caption>
                    <description/>
                </property>
                <property key="intButtonLabel" type="string" required="false" defaultValue="Open">
                    <caption>Label</caption>
                    <description>The label of the button to appear in the infowindow.</description> 
                </property>
                <property key="intButtonClass" type="string" required="false" defaultValue="esri-icon-launch-link-external">
                    <caption>Class</caption>
                    <description>The classes on the button to appear in the infowindow. By default mendix default classes are added. Those can be stripped and/or your own class added. One can also use the Esri Font library classes, available at: https://developers.arcgis.com/javascript/latest/esri-icon-font/</description> 
                </property>
                <property key="intButtonIcon" type="icon" required="false">
                    <caption>Icon</caption>
                    <description>Button Icon</description>             
				</property>
            </propertyGroup>
        </propertyGroup>
        <propertyGroup caption="Point Clustering">
            <propertyGroup caption="Enable">
                <property key="cl_enabled" type="boolean" defaultValue="false">
                    <caption>Enabled</caption>
                    <description>Decide whether clustering and all settings below should be used when displaying the map.</description> 
                </property>
            </propertyGroup>
            <propertyGroup caption="Count Text">
                <property key="cl_symbolTextColor" type="string" defaultValue="#000000">
                    <caption>Text Color</caption>
                    <description>The hexadecimal color or the counter amount to appear in the cluster.</description> 
                </property>
                <property key="cl_symbolTextSize" type="integer" defaultValue="14">
                    <caption>Text Size</caption>
                    <description>The text size for the counter appearing in the clustered point,</description> 
                </property>
            </propertyGroup>
            <propertyGroup caption="Popup">
                <property key="cl_popupTitle" type="string" defaultValue="Cluster Summary">
                    <caption>Popup Title</caption>
                    <description>The title of the popup to appear on click of a cluster.</description> 
                </property>
                <property key="cl_popupContent" type="string" defaultValue="This cluster represents {cluster_count} properties.">
                    <caption>Popup Title</caption>
                    <description>The content for the popup. {cluster_count} is an aggregated variable available within clusters to be used.</description> 
                </property>
            </propertyGroup>
            <propertyGroup caption="Sizing">
                <property key="cl_radius" type="integer" defaultValue="80">
                    <caption>Radius</caption>
                    <description>Radius for adjacent points to be clustered.</description> 
                </property>
                <property key="cl_minSize" type="integer" defaultValue="20">
                    <caption>Min Size</caption>
                    <description>Minimum Size for clustering</description> 
                </property>
                <property key="cl_maxSize" type="integer" defaultValue="100">
                    <caption>Max Size</caption>
                    <description>Maximum Size for clustering</description> 
                </property>
            </propertyGroup>
        </propertyGroup>
        <propertyGroup caption="Authentication">
            <propertyGroup caption="Registration">
                <property key="authPortalURL" type="string" defaultValue="https://www.arcgisonline.com">
                    <caption>Portal URL</caption>
                    <description>The client specific portal URL if authentication against a specific client ArcGIS server is needed. Doesn't enforce OAuth, but redirects user to correct portal to log in.</description> 
                </property>
             </propertyGroup>
        </propertyGroup>       
   </properties>
</widget>


================================================
FILE: src/components/ArcGISContainer.tsx
================================================
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-ts-ignore */
import { useRef, useEffect, useState, createElement, memo } from "react";
import {
    ObjectItem,
    ListValue,
    ListAttributeValue,
    ListActionValue,
    DynamicValue,
    WebIcon,
    ListWidgetValue
} from "mendix";
import Expand from "@arcgis/core/widgets/Expand";
import Basemap from "@arcgis/core/Basemap";
import WebMap from "@arcgis/core/WebMap";
import MapView from "@arcgis/core/views/MapView";
import BasemapToggle from "@arcgis/core/widgets/BasemapToggle"
import Legend from "@arcgis/core/widgets/Legend";
import Search from "@arcgis/core/widgets/Search";
import LayerList from "@arcgis/core/widgets/LayerList";
import { GisObject, position, logNode } from "../ReactArcGIS";
import _createQueryDefinitions, { createLoadingIndicators, loadLayer, zoomToGraphics } from "../utils/Utils";
import {
    CsDefaultArrayType,
    CsLegendEntriesArrayType,
    IntAttributesArrayType,
    LayerArrayType,
    LayerServerTypeEnum
} from "../../typings/ReactArcGISProps";
import ServerInfo from "@arcgis/core/identity/ServerInfo";
import IdentityManager from "@arcgis/core/identity/IdentityManager";

export interface ArcGISContainerProps {
    onLoad: (isLoaded: boolean, view: MapView, legend: Legend) => void;
    mapWidth: number;
    mapHeight: number;
    baseMapID: string;
    bmToggleID: string;
    bmToggleEnabled: boolean;
    bmTogglePosition: position;
    bmTogglePlaceHolderIndex: number;
    defaultZoom: number;
    objectZoom: number;
    defaultLocation: number[];
    loadingBehavior: string;
    loadingModalMessage: string;
    mxObjects: ListValue;
    tokenAttr?: ListAttributeValue<string>;
    userIdAttr?: ListAttributeValue<string>;
    expiryDateAttr?: ListAttributeValue<Date>;
    dynLayerObjects?: ListValue;
    dynLayerLayerIDAttr?: ListAttributeValue<string>;
    dynLayerIndexAttr?: ListAttributeValue<BigJs.Big>;
    dynLayerServerTypeAttr?: ListAttributeValue<string>;
    dynLayerStaticURLAttr?: ListAttributeValue<string>;
    dynLayerObjectIDAttr?: ListAttributeValue<string>;
    dynLayerVisibilityOnLoadAttr?: ListAttributeValue<boolean>;
    dynLayerCustomStylingEnabledAttr?: ListAttributeValue<boolean>;
    dynLayerClusteringEnabledAttr?: ListAttributeValue<boolean>;
    dynLayerMendixObjectsAttr?: ListAttributeValue<boolean>;
    objectIDAttr: ListAttributeValue<BigJs.Big | string>;
    layerIDAttr: ListAttributeValue<BigJs.Big | string>;
    colorAttr?: ListAttributeValue<string>;
    sizeAttr?: ListAttributeValue<BigJs.Big>;
    symbolAttr?: ListAttributeValue<string>;
    dsShowAllObjects: boolean;
    dsHighlightingEnabled: boolean;
    csDefaultArray: CsDefaultArrayType[];
    csLegendEntriesArray: CsLegendEntriesArrayType[];
    legendEnabled: boolean;
    legendStartExpanded: boolean;
    legendPosition: position;
    legendTitle: string;
    legendPlaceHolderIndex: number;
    searchEnabled: boolean;
    searchStartExpanded: boolean;
    searchPosition: position;
    searchPlaceHolderIndex: number;
    toggleLayerEnabled: boolean;
    toggleLayerStartExpanded: boolean;
    toggleLayerPosition: position;
    toggleLayerPlaceHolderIndex: number;
    // filterOptions: FilterOption[];
    layerArray: LayerArrayType[];
    intAttributesArray: IntAttributesArrayType[];
    intMendixXPathStringr: string;
    intButtonAction?: ListActionValue;
    intButtonLabel: string;
    intButtonClass: string;
    intButtonIcon?: DynamicValue<WebIcon>;
    infoWindowWidget?: ListWidgetValue;
    cl_enabled: boolean;
    cl_symbolTextColor: string;
    cl_symbolTextSize: number;
    cl_popupTitle: string;
    cl_popupContent: string;
    cl_radius: number;
    cl_minSize: number;
    cl_maxSize: number;
    authPortalURL: string;
    isLoaded: boolean; // workaround to store isLoaded state of functional component over refreshes
    view: MapView;
    legend: Legend;
}

export interface QueryDefinition {
    layerID: string;
    layerURL: string;
    queryDefinitionOriginal: string;
    queryDefinition: string;
}

export interface FieldInfo {
    fieldName: string;
    visible: boolean;
    label: string;
}

const ArcGISContainer = memo((props: ArcGISContainerProps) => {
    const [queryDefinitions] = useState<QueryDefinition[]>([]);
    const [isLoaded, setIsLoaded] = useState<boolean>(props.isLoaded);
    // const [view, setView] = useState<MapView>(props.view);
    let [gisObjects] = useState<GisObject[]>([]);
    const [mendixLayer] = useState<LayerArrayType[]>([]);
    const mendixLayersRef = useRef(mendixLayer);
    const [mendixLayerAttr] = useState<IntAttributesArrayType[]>([]);
    const mendixLayersAttrRef = useRef(mendixLayerAttr);
    const [mxObjects, setMxObjects] = useState<ObjectItem[]>([]);
    const [highlights] = useState<any[]>([]);
    const gisObjectsRef = useRef(gisObjects);
    const mxObjectsRef = useRef(mxObjects);
    // console.debug(logNode + "rendering ArcGISContainer");

    // see: https://stackoverflow.com/questions/58017215/what-typescript-type-do-i-use-with-useref-hook-when-setting-current-manually
    const mapDiv = useRef<HTMLDivElement | null>(null);
    const loadingDiv = useRef<HTMLDivElement | null>(null);
    const [progressId] = useState<number>();
    const progressIdRef = useRef(progressId); 
    const [blockProgressModal] = useState<boolean>(false);
    const blockProgressModalRef = useRef(blockProgressModal); 

    // console.warn(logNode + " isLoaded boolean: " + props.isLoaded);

    // only load dynamic layers at first render!
    if (!isLoaded) {
        if (props.dynLayerObjects && props.dynLayerObjects.items) {
            // console.debug(logNode + "token source:");
            // console.dir(props.tokenObjects);
            // eslint-disable-next-line array-callback-return
            props.dynLayerObjects.items.map(dynLayerObj => {
                if (props.dynLayerLayerIDAttr && props.dynLayerStaticURLAttr && props.dynLayerObjectIDAttr) {
                    let dynServerType: LayerServerTypeEnum = "FeatureServer";
                    let dynMendixLayer = false;
                    let dynVisibilityOnLoad = true;
                    let dynCustomStylingEnabled = false;
                    let dynClusteringEnabled = false;
                    let dynIndex = 1;
                    if (props.dynLayerServerTypeAttr) {
                        // @ts-ignore
                        if (String(props.dynLayerServerTypeAttr.get(dynLayerObj).value) === "MapServer") {
                            dynServerType = "MapServer";
                            // @ts-ignore
                        } else if (String(props.dynLayerServerTypeAttr.get(dynLayerObj).value) === "PortalItem") {
                            dynServerType = "PortalItem";
                        }
                    }
                    if (props.dynLayerMendixObjectsAttr) {
                        // @ts-ignore
                        if (props.dynLayerMendixObjectsAttr.get(dynLayerObj).value) {
                            dynMendixLayer = true;
                        }
                    }
                    if (props.dynLayerIndexAttr) {
                        // @ts-ignore
                        if (props.dynLayerIndexAttr.get(dynLayerObj).value) {
                            // @ts-ignore
                            dynIndex = props.dynLayerIndexAttr.get(dynLayerObj).value;
                        }
                    }
                    if (props.dynLayerVisibilityOnLoadAttr) {
                        // @ts-ignore
                        dynVisibilityOnLoad = props.dynLayerVisibilityOnLoadAttr.get(dynLayerObj).value;
                    }
                    if (props.dynLayerCustomStylingEnabledAttr) {
                        // @ts-ignore
                        dynCustomStylingEnabled = props.dynLayerCustomStylingEnabledAttr.get(dynLayerObj).value;
                    }
                    if (props.dynLayerClusteringEnabledAttr) {
                        // @ts-ignore
                        dynClusteringEnabled = props.dynLayerClusteringEnabledAttr.get(dynLayerObj).value;
                    }
                    const dynamicLayer: LayerArrayType = {
                        // @ts-ignore
                        layerID: String(props.dynLayerLayerIDAttr.get(dynLayerObj).value),
                        // @ts-ignore
                        layerURLStatic: String(props.dynLayerStaticURLAttr.get(dynLayerObj).value),
                        // @ts-ignore
                        objectIDAttr: String(props.dynLayerObjectIDAttr.get(dynLayerObj).value),
                        layerIndex: dynIndex,
                        layerServerType: dynServerType,
                        clientIDAttr: "",
                        clientIDAttrType: "String",
                        opacity: "0",
                        showAttribution: true,
                        mendixLayer: dynMendixLayer,
                        featureLayerID: "0",
                        visibilityOnLoad: dynVisibilityOnLoad,
                        customStylingEnabled: dynCustomStylingEnabled,
                        clusteringEnabled: dynClusteringEnabled,
                        visibleLayerIndexes: "",
                        // @ts-ignore
                        portalItemID: String(props.dynLayerLayerIDAttr.get(dynLayerObj).value)
                    };
                    const dynamicLayerExisting = props.layerArray.find(obj => {
                        return obj.layerID === dynamicLayer.layerID;
                    });
                    if (!dynamicLayerExisting) {
                        props.layerArray.push(dynamicLayer);
                    }
                }
            });
        }

        // make sure the mendixLayer is loaded last, so it is loaded on top of supporting layer content
        props.layerArray.sort((layer, layerAdj) => {
            // false values first
            return layer.mendixLayer === layerAdj.mendixLayer ? 0 : layer.mendixLayer ? 1 : -1;
        });
        // add all Mendix Layers to Ref to access later on
        mendixLayersRef.current = props.layerArray.filter(layer => {
            return layer.mendixLayer;
        });
        // add all attributes configured for Mendix layers to Ref as well
        const intAttributesArray: IntAttributesArrayType[] = [];
        props.layerArray.forEach(layer => {
            props.intAttributesArray.forEach(intAttributes => {
                if (intAttributes.intAttributeLayerID === layer.layerID) {
                    intAttributesArray.push(intAttributes);
                }
            });
        });
        mendixLayersAttrRef.current = intAttributesArray;
    }

    useEffect(() => {
        const newGisObjects: GisObject[] = [];
        let newMxObjects: ObjectItem[] = [];
		let objectChange = false;
        if (props.mxObjects && props.mxObjects.items) {
            // if (!mxObjectsRef.current || mxObjectsRef.current.length === 0) {
            newMxObjects = props.mxObjects.items;
            /* } else {
                newMxObjects = mxObjectsRef.current;
            }*/
        }
        if (newMxObjects) {
            // console.debug(logNode + "data source of map objects:");
            // eslint-disable-next-line array-callback-return
            newMxObjects.map(mxObject => {
                // @ts-ignore
                const ID = String(props.objectIDAttr.get(mxObject).value);
                // @ts-ignore
                const layerID = String(props.layerIDAttr.get(mxObject).value);
                let color = "FF0000";
                let size = 8;
                let symbol = "circle";
                if (props.colorAttr) {
                    // @ts-ignore
                    color = String(props.colorAttr.get(mxObject).value);
                }
                if (props.sizeAttr) {
                    // @ts-ignore
                    size = Number(props.sizeAttr.get(mxObject).value);
                }
                if (props.symbolAttr) {
                    // @ts-ignore
                    symbol = String(props.symbolAttr.get(mxObject).value);
                }
                const gisObject = {
                    ID,
                    layerID,
                    color,
                    size,
                    symbol,
                    mxGuid: mxObject.id
                } as GisObject;
                newGisObjects.push(gisObject);
            });
        }
        // console.debug("gisobjects");
        // console.dir(gisObjects);
        if (isLoaded) {
			const messagePostfix = "Amount of objects changed from " + mxObjectsRef.current.length + " to " + newGisObjects.length 
            // there are 3 scenario's which should trigger a reload
            // scenario 1: object amount changed
            if (newMxObjects.length !== mxObjectsRef.current.length) {
                console.debug(logNode + "reloading scenario 1: " + messagePostfix);
                objectChange = true;
            } else if (mxObjectsRef.current.length === newMxObjects.length && newMxObjects.length >= 1) {
                // Same amount of ojects after reload
                // scenario 2/3: check if object changes, so if ID's and appearance (color, size, symbol) are still the same
                for (var i = 0; i <  newGisObjects.length ; i++) {
                    const gisObjectFound = gisObjectsRef.current.filter(oldGisObject => 
                        oldGisObject.ID === newGisObjects[i].ID && 
                        oldGisObject.color === newGisObjects[i].color &&
                        oldGisObject.size === newGisObjects[i].size &&
                        oldGisObject.symbol=== newGisObjects[i].symbol
                    )
                    if (gisObjectFound.length === 0){
                        objectChange = true;
                        console.debug(logNode + "reloading scenario 2/3: " + messagePostfix +  " (amount of objects same but id's or appearance changed)");
                        break;
                    }
                }
            }
			if (!objectChange){
                console.debug(logNode + "reloading scenario 4: " + messagePostfix + " (no object amount, id,nor appearance changed. No new zooming... )"); 
            }
        }        
        // update the new references for usage AFTER all data loading checks
        gisObjects = newGisObjects;
        gisObjectsRef.current = gisObjects;
        mxObjectsRef.current = newMxObjects;
        setMxObjects(mxObjects);

        if (!isLoaded) {
            console.debug(logNode + "useEffect hook triggered on initial load!");
            // esriConfig.apiKey = props.APIKey;
            let serverInfo = new ServerInfo();
            serverInfo.server = props.authPortalURL;
            serverInfo.tokenServiceUrl = props.authPortalURL + "/arcgis/tokens/generateToken";
            serverInfo.hasServer = true;
            IdentityManager.registerServers([serverInfo]);
            
            // generate query definitions for all layers based on loaded mx objects
            _createQueryDefinitions(queryDefinitions, props.layerArray, gisObjects);
            if (mapDiv.current != null) {
                // Initialize map dimensions
                if (props.mapWidth === 10000) {
                    mapDiv.current.style.width = "100%";
                } else {
                    mapDiv.current.style.width = props.mapWidth + "px";
                }
                if (props.mapHeight === 10000) {
                    mapDiv.current.style.height = "100vh";
                } else {
                    mapDiv.current.style.height = props.mapHeight + "px";
                }
                // load the base map as basis map
                const webMap = new WebMap({
                    basemap: Basemap.fromId(props.baseMapID)
                });

                const view = new MapView({
                    container: mapDiv.current,
                    map: webMap,
                    zoom: props.defaultZoom,
                    center: props.defaultLocation
                });

                if (props.bmToggleEnabled) {
                    // 1 - Create the widget
                    const toggle = new BasemapToggle({
                        // 2 - Set properties
                        view: view, // view that provides access to the map's 'topo-vector' basemap
                        nextBasemap: props.bmToggleID // allows for toggling to the 'hybrid' basemap
                    });

                    // Add widget to the bottom right corner of the view
                    view.ui.add(toggle, {
                        position: props.bmTogglePosition,
                        index: props.bmTogglePlaceHolderIndex
                    });
                }
                // either creating loading indicator (spinning round) or progress modal based on widget settings
                createLoadingIndicators(view,props.loadingBehavior,props.loadingModalMessage,progressIdRef,loadingDiv, blockProgressModalRef);

                const mendixLayerpromises: Array<Promise<any>> = [];
                const mendixLayers = props.layerArray.filter(layer => {
                    return layer.mendixLayer;
                });
                // load Mendix layers first
                mendixLayers.forEach(mendixLayerObj => {
                    loadLayer(props, mendixLayerObj, queryDefinitions, mendixLayersRef, webMap, view, mendixLayerpromises);
                });
                // and trigger zooming for Mendix layers
                Promise.all(mendixLayerpromises).then(() => {
                    console.debug(logNode +"Initial load: all Mendix Layer views loaded");
                    if (gisObjects && gisObjects.length && gisObjects.length > 0) {
                        const zoomDonePromise = zoomToGraphics(view, gisObjects, queryDefinitions, props, highlights);
                        zoomDonePromise.then(()=> {
                            console.debug(logNode +"Initial load: Zoomed to Mendix objects, blocking loading indicator and loading other layers now...")
                            blockProgressModalRef.current = true;
                            if (progressIdRef && progressIdRef.current){
                                mx.ui.hideProgress(progressIdRef.current);
                                progressIdRef.current = undefined;
                            }
                            
                            // and afterwards load other layers
                            const otherLayers = props.layerArray.filter(layer => {
                                return !layer.mendixLayer;
                            });
                            if (otherLayers.length > 0) {
                                const otherLayerpromises: Array<Promise<any>> = [];
                                otherLayers.forEach(otherLayerObj => {
                                    loadLayer(props, otherLayerObj, queryDefinitions, mendixLayersRef, webMap, view, otherLayerpromises);
                                });
                                Promise.all(otherLayerpromises).then(() => {
                                    console.debug(logNode +"Initial load: all other layer views loaded, removing block on loading indicator...");
                                    blockProgressModalRef.current = false;
                                });
                            } else {
                                console.debug(logNode +"Initial load: no other layers than Mendix layers, removing block on loading indicator...");
                                blockProgressModalRef.current = false;
                            }
                        })
                    }
                });

                // Event handler that fires each time an action is clicked.
                view.popup.on("trigger-action", event => {
                    // console.dir(event.action);
                    // get identifier of grapic in layer
                    // console.debug(logNode + " selected feature from popup:");
                    // console.dir(view.popup.selectedFeature);
                    if (mxObjectsRef.current && mendixLayersRef.current) {
                        const feature = view.popup.selectedFeature;
                        // get Mendix layer equivalent where graphic belong to via shared URL attribute
                        const layerURL = String(feature.layer.get("url")) + "/" + String(feature.layer.get("layerId"));
                        // console.dir(logNode + "URL of layer clicked: " + layerURL);
                        const layer = props.layerArray.filter(layer => {
                            return layer.layerURLStatic === layerURL;
                        })[0];

                        const graphicID = view.popup.selectedFeature.getAttribute(layer.objectIDAttr);
                        // console.debug("mxObjectsRef.current");
                        // console.dir(mxObjectsRef.current);
                        const mxObject = mxObjectsRef.current.filter(mxObject => {
                            // console.debug("Mendix Object Value:" + String(props.objectIDAttr(mxObject).value));
                            // console.debug("ArcGIS Graphic value:" + String(graphicID));
                            // @ts-ignore
                            return String(props.objectIDAttr.get(mxObject).value) === String(graphicID);
                        })[0];
                        // console.debug("mxObject");
                        // console.dir(mxObject);
                        // Execute the measureThis() function if the measure-this action is clicked
                        if (event.action.id === "pop-mx-action-default-" + layer.layerID) {
                            if (mxObject && props.intButtonAction) {
                                console.debug(
                                    logNode +
                                        "triggering on click action for graphic with " +
                                        layer.objectIDAttr +
                                        " " +
                                        graphicID +
                                        " of layer " +
                                        layer.layerID
                                );
                                // @ts-ignore
                                props.intButtonAction.get(mxObject).execute();
                            }
                        } else {
                            console.debug(
                                logNode + event.action.id + " clicked with Mendix Context Object ID: " + mxObject.id
                            );
                        }
                    }
                });
                let legend: Legend;
                view.when(() => {
                    if (props.legendEnabled) {
                        // get the first layer in the collection of operational layers in the WebMap
                        // when the resources in the MapView have loaded.
                        const webLayers = webMap.layers;
                        const layerInfos: any[] = [];
                        // TODO: 20210905 - Ivo Sturm: getting the Mendix layer should not be needed anymore if we store layerInfos in cache.
                        webLayers.forEach(webLayer => {
                            // console.debug(logNode + featureLayer.title);
                            // console.dir(featureLayer);
                            const layerMendix = props.layerArray.filter(layer => {
                                // console.debug(logNode + layer.layerServerType + " : " + layer.layerID);
                                if (
                                    layer.layerServerType === "FeatureServer" ||
                                    layer.layerServerType === "MapServer"
                                ) {
                                    return (
                                        layer.layerURLStatic ===
                                        String(webLayer.get("url")) + "/" + String(webLayer.get("layerId"))
                                    );
                                } /* else if (layer.layerServerType === "MapServer") {
                                    return layer.layerURLStatic === String(featureLayer.get("url"));
                                } */ else if (
                                    layer.layerServerType === "PortalItem"
                                ) {
                                    const portalItem: any = webLayer.get("portalItem");
                                    return portalItem && layer.layerID === portalItem.id;
                                } else {
                                    return false;
                                }
                            })[0];
                            let title = "";
                            if (layerMendix) {
                                title = layerMendix.layerID;
                                // for a portalItem get the name from the Portal Item itself instead of from Mendix
                                if (layerMendix.layerServerType === "PortalItem") {
                                    const portalItem: any = webLayer.get("portalItem");
                                    title = portalItem.title;
                                    // for a PortalItem, the layer needs to be loaded first to get access to the legend
                                    webLayer.visible = layerMendix.visibilityOnLoad;
                                    console.error(
                                        logNode +
                                            title +
                                            "setting visibility on load to:" +
                                            layerMendix.visibilityOnLoad
                                    );
                                }
                            } else {
                                // dummy legend layer used for showing legend for layers with custom styling
                                title = webLayer.title;
                            }
                            layerInfos.push({
                                layer: webLayer,
                                title: webLayer.title,
                                hideLayers: []
                            });
                        });
                        if (webLayers) {
                            legend = new Legend({
                                view,
                                layerInfos
                            });
                            const legendExpand = new Expand({
                                view,
                                content: legend,
                                expanded: props.legendStartExpanded
                            });
                            // Add widget to the bottom right corner of the view
                            view.ui.add(legendExpand, {
                                position: props.legendPosition,
                                index: props.legendPlaceHolderIndex
                            });
                        }
                    }
                    if (props.searchEnabled) {
                        // get the first layer in the collection of operational layers in the WebMap
                        // when the resources in the MapView have loaded.
                        const searchWidget = new Search({
                            view
                        });

                        if (searchWidget) {
                            const searchExpand = new Expand({
                                view,
                                content: searchWidget,
                                expanded: props.searchStartExpanded
                            });
                            // Add widget to the bottom right corner of the view
                            view.ui.add(searchExpand, {
                                position: props.searchPosition,
                                index: props.searchPlaceHolderIndex
                            });
                        }
                    }
                    // eslint-disable-next-line no-constant-condition
                    if (props.toggleLayerEnabled) {
                        // don't show dummy layers, created only for showing legend of layers with custom styling
                        const dummyLayers = view.map.layers
                            /* .flatten(item => {
                                return item.layers || item.sublayers;
                            }) */
                            .filter(layer => {
                                return layer.id === "Dummy";
                            });
                        dummyLayers.forEach(dummyLayer => {
                            dummyLayer.listMode = "hide";
                        });
                        const layerList = new LayerList({
                            view
                        });
                        const layerListExpand = new Expand({
                            view,
                            content: layerList,
                            expanded: props.toggleLayerStartExpanded
                        });
                        // Add widget to the bottom right corner of the view
                        view.ui.add(layerListExpand, {
                            position: props.toggleLayerPosition,
                            index: props.toggleLayerPlaceHolderIndex
                        });
                    }
                    // add view and legend to parent state, so it can be accessed after reload of parent
                    // add view to state, so it can be accessed after reload
                    props.onLoad(true, view, legend);
                    setIsLoaded(true);
                    // setView(view);
                    setMxObjects(mxObjects);
                });
            }
        } else if (objectChange) {
            console.debug(logNode + "useEffect hook triggered after initial load with object change!");
            if (props.view) {
                // if at initial load no mxobjects where available, possible in listen to grid scenario
                // then querydefinitions need to be built still
                // generate query definitions for all layers based on loaded mx objects
                if (queryDefinitions.length === 0) {
                    _createQueryDefinitions(queryDefinitions, props.layerArray, gisObjects);
                }
                // after intial load, only zoom to objects since all setup should already be done at initial load
                zoomToGraphics(props.view, gisObjects, queryDefinitions, props, highlights);
            }
        }
    }, [queryDefinitions, props.mxObjects, highlights]);
    return (
        <div className="mapDiv" ref={mapDiv}>
            {props.loadingBehavior === "animatedGIF" ? (
                <div id="loading" ref={loadingDiv}>
                    <img src="./widgets/valcon/reactarcgis/assets/custom/loading.gif" />
                </div>
            ) : null}
        </div>
    );
});

export default ArcGISContainer;



================================================
FILE: src/components/CustomPopup.tsx
================================================
/* eslint-disable linebreak-style */
import { Component, createElement, ReactNode } from "react";
import { IntAttributesArrayType } from "../../typings/ReactArcGISProps";

export interface CustomPopupProps {
    attributes: IntAttributesArrayType[];
}

export default class CustomPopup extends Component<CustomPopupProps> {
    render(): ReactNode {
        return (
            <div
                id="esri-popup-table"
                className="esri-feature__content-element"
                style={{ display: "block" }}
                title="popup table"
            >
                <div className="esri-feature-fields">
                    <div className={"esri-feature-element-info"}></div>
                    <table className={"esri-widget__table"} summary={"Lijst met attributen en waarden"}>
                        <tbody>
                            {this.props.attributes.map(
                                (intAttribute, index) => (
                                    <tr key={index}>
                                        <th className={"esri-feature-fields__field-header"}>
                                            {intAttribute.intAttributeLabel}
                                        </th>
                                        <td
                                            className={"esri-feature-fields__field-data"}
                                            id={"popup_" + intAttribute.intAttributeName}
                                        ></td>
                                    </tr>
                                )
                                // )
                            )}
                        </tbody>
                    </table>
                </div>
            </div>
        );
    }
}



================================================
FILE: src/ui/ReactArcGIS.css
================================================
/*
Place your custom CSS here
*/
div#arcgis-filter {
    height: 80px;
    width: 120px;
  }
  
  #arcgis-filter {
      height: 80px;
      width: 100%;
      visibility: hidden;
    }
  
    .arcgis-filter-item {
      width: 100%;
      padding: 12px;
      text-align: center;
      vertical-align: baseline;
      cursor: pointer;
      height: 40px;
      text-align: inherit
    }
  
    .arcgis-filter-item:focus {
      background-color: dimgrey;
    }
  
    .arcgis-filter-item:hover {
      background-color: dimgrey;
    }
  
    #loading {
      margin: 0;
      position: absolute;
      top: 50%;
      left: 50%;
      margin-right: -50%;
    }


================================================
FILE: src/utils/CustomStylingUtils.tsx
================================================
/* eslint-disable linebreak-style */
import Color from "@arcgis/core/Color";
import { CsDefaultArrayType, CsLegendEntriesArrayType, LayerArrayType } from "../../typings/ReactArcGISProps";
import UniqueValueRenderer from "@arcgis/core/renderers/UniqueValueRenderer";
import SimpleMarkerSymbol from "@arcgis/core/symbols/SimpleMarkerSymbol";
import { GisObject, logNode } from "../ReactArcGIS";
import FeatureLayer from "@arcgis/core/layers/FeatureLayer";
// import ReactDOM from "react-dom";
// import CustomLegend from "../components/CustomLegend";
// import { createElement } from "react";

export function _createUniqueValueRenderer(
    layer: LayerArrayType,
    gisObjects: GisObject[],
    csDefaultArray: CsDefaultArrayType,
    layerArcGIS: FeatureLayer
): UniqueValueRenderer {
    let field = layer.objectIDAttr;
    let fieldTypeIsNumber = true;
    if (layer.clientIDAttr && layer.clientIDAttr !== "") {
        field = layer.clientIDAttr;
        fieldTypeIsNumber = false;
    }
    let defaultSymbol = layerArcGIS.renderer.get("symbol");
    // if csDefaultArray configured, use that symbol to overrule default symbol for layer
    if (csDefaultArray) {
        defaultSymbol = _createSimpleMarkerSymbol(
            csDefaultArray.csDefaultArraySymbol,
            csDefaultArray.csDefaultArrayColor,
            csDefaultArray.csDefaultArraySize
        );
    }
    const uniqueValueRenderer: any = {
        type: "unique-value",
        field,
        defaultSymbol,
        uniqueValueInfos: [],
        legendOptions: {
            title: ""
        }
    };
    gisObjects.forEach(gisObject => {
        const color = gisObject.color;
        const symbol = gisObject.symbol;
        const size = gisObject.size;
        if (color) {
            uniqueValueRenderer.uniqueValueInfos.push({
                // in Mendix user has total freedom to assign color to GISObject based on Mendix logic
                value: _createRendererValue(fieldTypeIsNumber, gisObject.ID),
                symbol: _createSimpleMarkerSymbol(symbol, color, size)
            });
        }
    });
    return uniqueValueRenderer;
}

function _createSimpleMarkerSymbol(markerSymbol: string, color: string, size: number): SimpleMarkerSymbol {
    const simpleMarkerSymbol = new SimpleMarkerSymbol();
    // default to circle
    simpleMarkerSymbol.style = "circle";
    switch (markerSymbol) {
        case "cross":
            simpleMarkerSymbol.style = "cross";
            break;
        case "diamond":
            simpleMarkerSymbol.style = "diamond";
            break;
        case "square":
            simpleMarkerSymbol.style = "square";
            break;
        case "x":
            simpleMarkerSymbol.style = "x";
            break;
    }
    simpleMarkerSymbol.color = new Color(color);
    simpleMarkerSymbol.size = size;
    return simpleMarkerSymbol;
}
function _createRendererValue(fieldTypeIsNumber: boolean, ID: string | number): string | number {
    if (fieldTypeIsNumber) {
        return Number(ID);
    } else {
        return String(ID);
    }
}

export function createLegendUniqueValueRender(
    csLegendEntriesArray: CsLegendEntriesArrayType[],
    layer: LayerArrayType
): UniqueValueRenderer {
    console.log(logNode + "custom styling: updating legend for layer" + layer.layerID);
    const csLegendEntries = csLegendEntriesArray.filter(legendEntry => {
        return legendEntry.csLegendEntryLayerID === layer.layerID;
    });
    const uniqueLegendValueRenderer: any = {
        type: "unique-value", // autocasts as new UniqueValueRenderer()
        legendOptions: {
            title: " "
        },
        field: "ObjectID",
        uniqueValueInfos: []
    };
    csLegendEntries.forEach(csLegendEntry => {
        const color = csLegendEntry.csLegendEntryColor;
        const symbol = csLegendEntry.csLegendEntrySymbol;
        const size = csLegendEntry.csLegendEntrySize;
        if (color) {
            uniqueLegendValueRenderer.uniqueValueInfos.push({
                // in Mendix user has total freedom to assign color to GISObject based on Mendix logic
                value: csLegendEntry.csLegendEntryName,
                symbol: _createSimpleMarkerSymbol(symbol, color, size),
                label: csLegendEntry.csLegendEntryName
            });
        }
    });

    return uniqueLegendValueRenderer;
}



================================================
FILE: src/utils/PopupUtils.tsx
================================================
/* eslint-disable linebreak-style */
import { createElement } from "react";
import ReactDOM from "react-dom";
import { IntAttributesArrayType, LayerArrayType } from "../../typings/ReactArcGISProps";
import { logNode } from "../ReactArcGIS";
import CustomPopup from "../components/CustomPopup";

/**
 *
 * In case of a FeatureLayer dynamic content, based out of both attributes owned in Mendix as well as
 * in ArcGIS can be created. For this also a separate Class 'CustomPopup' has been created
 */
export const createCustomContent = (
    feature: any,
    mendixLayerAttr: IntAttributesArrayType[],
    mendixLayer: LayerArrayType,
    intMendixXPathString: string
): Promise<HTMLElement | undefined> => {
    const div = document.createElement("div");
    ReactDOM.render(<CustomPopup attributes={mendixLayerAttr} />, div);
    let ArcGISDID = feature.graphic.getAttribute(mendixLayer.objectIDAttr);
    let ArcGISIDIDName = mendixLayer.objectIDAttr;
    if (mendixLayer.clientIDAttr) {
        if (mendixLayer.clientIDAttrType === "String") {
            ArcGISDID = "'" + feature.graphic.getAttribute(mendixLayer.clientIDAttr) + "'";
        } else {
            ArcGISDID = feature.graphic.getAttribute(mendixLayer.clientIDAttr);
        }
        ArcGISIDIDName = mendixLayer.clientIDAttr;
    }
    console.debug(ArcGISIDIDName + " " + ArcGISDID + " clicked! Retrieving Mendix object:");
    return (
        new Promise((resolve, reject) => {
            // eslint-disable-next-line no-undef
            mx.data.get({
                xpath: "//" + intMendixXPathString + "=" + ArcGISDID + "]",
                callback: objs => resolve(objs[0]),
                error: error => reject(error)
            });
        })
            // eslint-disable-next-line no-undef
            .then((mxObject: mendix.lib.MxObject) => {
                if (div) {
                    const dataTDElements = Array.from(div.getElementsByClassName("esri-feature-fields__field-data"));
                    // console.dir(dataTDElements);
                    dataTDElements.forEach(dataTDelement => {
                        // console.debug(dataTDelement.id);
                        const attribute = mendixLayerAttr.filter(attr => {
                            // console.debug("popup_" + attr.intAttributeName);
                            return "popup_" + attr.intAttributeName === dataTDelement.id;
                        })[0];
                        if (attribute) {
                            let attributeValue = "";
                            if (!attribute.intAttributeMendix) {
                                attributeValue = feature.graphic.getAttribute(attribute.intAttributeName);
                            } else {
                                /* console.debug(
                                    "attribute " + attribute.intAttributeName + " needs to be retrieved from Mendix!"
                                );*/
                                if (mxObject) {
                                    attributeValue = String(mxObject.get(attribute.intAttributeName));
                                } else {
                                    console.error(
                                        "attribute " +
                                            attribute.intAttributeName +
                                            " couldnt be retrieved, because mxObject not found!"
                                    );
                                }
                            }
                            if (attributeValue && attributeValue !== "") {
                                dataTDelement.innerHTML = attributeValue;
                            } else {
                                dataTDelement.innerHTML = " ";
                            }
                        }
                    });
                    return div;
                }
            })
            .catch(err => {
                console.error(
                    logNode +
                        " error getting Mendix object based on unique Esri identifier " +
                        mendixLayer.objectIDAttr +
                        ". Error: " +
                        err
                );
                return undefined;
            })
    );
};

export function _addButtonToActionArray(
    number: number,
    buttonIcon: any,
    buttonLabel: string,
    buttonClass: string,
    actionArray: any[],
    layerID: string
): void {
    if (buttonLabel === "DISABLE") {
        return;
    }
    const btnId = "pop-mx-action-" + number + "-" + layerID;
    let intButtonIconClass = "";
    if (buttonIcon?.value?.type === "glyph") {
        intButtonIconClass = " glyphicon " + buttonIcon.value.iconClass;
    }
    actionArray.push({
        title: buttonLabel,
        id: btnId,
        className: buttonClass + intButtonIconClass,
        type: "button"
    });
}



================================================
FILE: src/utils/Utils.tsx
================================================
/* eslint-disable linebreak-style */
import { LayerArrayType } from "../../typings/ReactArcGISProps";
import { GisObject, logNode } from "../ReactArcGIS";
import { ArcGISContainerProps, FieldInfo, QueryDefinition } from "../components/ArcGISContainer";
import Geometry from "@arcgis/core/geometry/Geometry";
import Graphic from "@arcgis/core/Graphic";
import { load, project } from "@arcgis/core/geometry/projection";
import MapView from "@arcgis/core/views/MapView";
import { createLegendUniqueValueRender, _createUniqueValueRenderer } from "./CustomStylingUtils";
import { whenFalse, whenFalseOnce, whenTrue } from "@arcgis/core/core/watchUtils";
import FeatureLayer from "@arcgis/core/layers/FeatureLayer";
import { createCustomContent } from "./PopupUtils";
import WebMap from "@arcgis/core/WebMap";
import PortalItem from "@arcgis/core/portal/PortalItem";
import Layer from "@arcgis/core/layers/Layer";

export interface QueryFeaturesResult {
    layerName: string;
    layerView: any;
    arcGISObjectIDAttr: string;
    result: any;
}

/**
 *
 * @param layerObj the layer object from Mendix
 * @param gisObjects the gisObjects loaded from the data source
 * @returns a specific query definition with all ArcGIS id's so layer can be constrained on these.
 */
export function _createQueryDefinition(layerObj: LayerArrayType, gisObjects: GisObject[]): string {
    let queryDefinition = "";
    let layerArcGISIDField = layerObj.objectIDAttr;
    let layerArcGISIDFieldType = "Number";
    if (layerObj.clientIDAttr) {
        layerArcGISIDField = layerObj.clientIDAttr;
        if (layerObj.clientIDAttrType === "String") {
            layerArcGISIDFieldType = "String";
        }
    }
    // create query definition if there are Mendix objects, but less than 4000 are selected / fed to ArcGIS. More than 4000 will give weird results.
    if (gisObjects.length > 0 && gisObjects.length < 4000 && layerObj.mendixLayer) {
        let firstIteration = true;

        const gisObjectsInLayer = gisObjects.filter(gisObject => {
            if (gisObject.layerID) {
                return gisObject.layerID === layerObj.layerID;
            }
            return null;
        });

        if (gisObjectsInLayer && gisObjectsInLayer.length > 0) {
            // create an IN statement for all retrieved objects
            queryDefinition = layerArcGISIDField + " IN (";
        }

        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let q = 0; q < gisObjects.length; q++) {
            const ArcGISID = String(gisObjects[q].ID);

            if (ArcGISID) {
                // only first time no postfix , should be added
                if (!firstIteration) {
                    queryDefinition += ",";
                }
                if (firstIteration) {
                    firstIteration = false;
                }
                if (layerArcGISIDFieldType === "String") {
                    queryDefinition += "'" + ArcGISID + "'";
                } else {
                    queryDefinition += ArcGISID;
                }
            }
        }

        if (gisObjectsInLayer && gisObjectsInLayer.length > 0) {
            // properly close the IN statement
            queryDefinition += ")";
        }
        console.debug(logNode + "queryDefinition for layer: " + layerObj.layerID + " : " + queryDefinition);
    } else {
        // in case of non Mendix layers, always load all objects since identifier is not known in Mendix!
        queryDefinition = "1=1";
    }
    return queryDefinition;
}

export default function _createQueryDefinitions(
    queryDefinitions: QueryDefinition[],
    layerArray: LayerArrayType[],
    gisObjects: GisObject[]
): void {
    if (layerArray) {
        if (queryDefinitions.length === 0) {
            layerArray.forEach(layer => {
                // only create new definitions at first load. after this should be updated
                // via handleDefinitionArrayUpdate
                const gisObjectsLayer = gisObjects.filter(gisObject => {
                    return layer.layerID === gisObject.layerID;
                });
                const queryDefinitionOriginal = _createQueryDefinition(layer, gisObjectsLayer);
                queryDefinitions.push({
                    layerID: layer.layerID,
                    layerURL: layer.layerURLStatic,
                    queryDefinitionOriginal,
                    queryDefinition: queryDefinitionOriginal
                });
            });
        }
    }
}
/**
 * @param view the view on which sketching is done
 * @param geometry of all graphics of the sketched rectangle in the layer
 * @returns Promise that will only resolve if all graphics are available
 */
export async function selectFeatures(view: any, geometry: any): Promise<any> {
    if (view) {
        // create a query and set its geometry parameter to the
        // rectangle that was drawn on the view
        const query = {
            geometry,
            outFields: ["*"]
        };
        // query graphics from the csv layer view. Geometry set for the query
        // can be polygon for point features and only intersecting geometries are returned
        let resultfeatures: any;

        await view.queryFeatures(query).then((result: any) => {
            resultfeatures = result;
        });
        return resultfeatures;
    }
}
/**
 * @param highlights array of highlighted features
 * @param result array of graphics needing highlighting
 * @param view which is active
 * @param layerView of the layer eing skected in
 * @param objectIDAttr of the Mendix object containing the ArcGIS ID
 * @param objectZoom the zoom number to use once highlighting
 * @param zoom decides whether to zoom (true) or not (false)
 * @param highlightEnabled decides whether to use highlighting of mx objects (true) or not (false)
 */
export function highlightAndZoom(
    highlights: any,
    QFResults: QueryFeaturesResult[],
    view: MapView,
    objectZoom: number,
    zoom: boolean,
    highlightEnabled: boolean
): Array<Promise<any>> {
    const promisesGoTo: Array<Promise<any>> = [];
    const newHighlights = highlights;
    if (highlightEnabled) {
        if (newHighlights.length > 0) {
            newHighlights.forEach((highlight: any) => {
                highlight.remove();
            });
        }
    }
    const geometriesReturned: Geometry[] = [];
    // the projection module is loaded. Geometries can be re-projected.
    load().then(() => {
        QFResults.forEach(QFResult => {
            const result = QFResult.result;
            let projectNeeded = false;
            const geometriesLayer: Geometry[] = [];
            if (result.features && result.features.length && result.features.length > 0) {
                // from QueryDefinition geometry is returned, from selection via rectangle on map they aren't, hence skip in that scenario
                if (result.features[0] && result.features[0].geometry) {
                    const spatRefGraphic = result.features[0].geometry.spatialReference.wkid;
                    if (spatRefGraphic !== view.spatialReference.wkid) {
                        projectNeeded = true;
                        console.debug(
                            logNode +
                                "spatial reference of graphics (" +
                                spatRefGraphic +
                                ") from layer " +
                                QFResult.layerName +
                                " is different from spatial reference from view (" +
                                view.spatialReference.wkid +
                                ")"
                        );
                    }
                }
                result.features.forEach((graphic: Graphic) => {
                    if (projectNeeded) {
                        // project returns Geometry | Geometry[]; TypeScript doesn't like this
                        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                        // @ts-ignore
                        graphic.geometry = project(graphic.geometry, view.spatialReference);
                    }
                    geometriesLayer.push(graphic.geometry);
                    if (highlightEnabled) {
                        // highlighting can only be done on actual ArcGIS esriID
                        const highlight = QFResult.layerView.highlight(graphic.attributes[QFResult.arcGISObjectIDAttr]);
                        newHighlights.push(highlight);
                    }
                });

                geometriesReturned.push(...geometriesLayer);
            }
        });
        if (highlightEnabled) {
            highlights = newHighlights;
        }
        let singleItem = true;
        let singlePointItem = false;
        if (geometriesReturned && geometriesReturned.length > 1) {
            singleItem = false;
        } else if ((geometriesReturned[0] && geometriesReturned[0].type ==="point") || geometriesReturned.length === 0) {
            singlePointItem = true;
        } 
        if (zoom) {
            const goToOpts2D = {
                animate: true,
                duration: 2000,
                easing: "ease"
            };
            // for multiple items (and single non-point item), GoTo zooms to features with proper zooming
            if (!singleItem || !singlePointItem) {
                promisesGoTo.push(
                    view.goTo({
                        target: geometriesReturned,
                        options: goToOpts2D
                    })
                );
            } // for single point items, GoTo doesn't zoom properly, whereas for PolyLine /Polygon it does.. so adjusting zoom based on Studio Pro setting
            else {
                console.debug(logNode + "zooming to single point using widget setting 'single item zoom level':" + objectZoom);
                promisesGoTo.push(
                    view.goTo({
                        target: geometriesReturned,
                        zoom: objectZoom,
                        options: goToOpts2D
                    })
                );
            }
        }
    });
    return promisesGoTo;
}

/**
 * a function that, based on the querydefinitions of each layer loaded, zooms to the objects in the Mendix layers.
 * It also adds highlighting to the objects, in case all other objects are also shown still, to make explicit which
 * objects are selected
 */
export const zoomToGraphics = (
    view: MapView,
    gisObjects: GisObject[],
    queryDefinitions: QueryDefinition[],
    props: ArcGISContainerProps,
    highlights: any[]
): Promise<any> => {
    return new Promise((resolve, reject) => {
        console.debug(logNode + "zooming to objects from data source..");
        // let definitionExpression: any = {};
        if (gisObjects && gisObjects.length > 0) {
            // assume all Mendix Layers should be queried
            const mendixLayers = props.layerArray.filter(layer => {
                return layer.mendixLayer;
            });
            if (mendixLayers && mendixLayers.length > 0) {
                const promisesLayerQuery: Array<Promise<any>> = [];

                mendixLayers.forEach(layer => {
                    // get all objects from that layer
                    const gisObjectsLayer = gisObjects.filter(gisObject => {
                        return layer.layerID === gisObject.layerID;
                    });
                    // only highlight and zoom if any objects are returned
                    if (gisObjectsLayer.length > 0) {
                        // get querydefinition to translate from layerID to layerURL also stored in layerview
                        const queryDef = queryDefinitions.filter(queryDef => {
                            return queryDef.layerID === layer.layerID;
                        })[0];

                        if (queryDef) {
                            queryDef.queryDefinitionOriginal = _createQueryDefinition(layer, gisObjectsLayer);
                        }
                        const objectIdAttribute = layer.objectIDAttr;
                        // iterate over layerviews, comparing layer url property
                        // filtering out the one layer which is connected to Mendix objects
                        if (view && queryDef) {
                            let layerViewCurrent: any = {};
                            view.layerViews.forEach(layerView => {
                                const layerViewURL = String(layerView.layer.get("url")) + "/" + String(layerView.layer.get("layerId"));
                                // console.debug(logNode + "Query definition: " + queryDef.layerURL + ". Matching with layers of view being iterated over, URL: " + layerViewURL);
                                if (queryDef.layerURL === layerViewURL) {
                                    layerViewCurrent = layerView;
                                    // console.debug(logNode + "MATCH! Query definition: " + queryDef.layerURL + ". Matching with layers of view being iterated over, URL: " + layerViewURL);
                                
                                }
                            });
                            if (layerViewCurrent && layerViewCurrent.layer) {
                                const featureLayer: FeatureLayer = layerViewCurrent.layer;
                                // reset the query definition when the Mendix Layer is done loading for the first time,
                                // to make sure scenario of feeding new MxObjects to widget when loading previous MxObjects is covered
                                if (!props.dsShowAllObjects) {
                                    console.debug(
                                        logNode +
                                            "setting definitionExpression on layer " +
                                            featureLayer.id +
                                            " to " +
                                            queryDef.queryDefinitionOriginal
                                    );
                                    featureLayer.definitionExpression = queryDef.queryDefinitionOriginal;

                                    console.debug(
                                        logNode + "layerview " + featureLayer.id + " resetting definition expression.."
                                    );
                                }
                                // if custom styling enabled and Mendix objects found for that layer, check if gisobjects need specific coloring
                                if (
                                    layer.customStylingEnabled &&
                                    gisObjectsLayer &&
                                    gisObjectsLayer.length &&
                                    gisObjectsLayer.length > 0
                                ) {
                                    // get default Color / Symbol settings for this layer
                                    const csDefaultArrayLayer = props.csDefaultArray.filter(csDefaultArrayInstance => {
                                        return layer.layerID === csDefaultArrayInstance.csDefaultArrayLayerID;
                                    })[0];
                                    console.debug(logNode + "applying custom styling to layer " + layer.layerID);
                                    const renderer = _createUniqueValueRenderer(
                                        layer,
                                        gisObjectsLayer,
                                        csDefaultArrayLayer,
                                        layerViewCurrent.layer
                                    );
                                    featureLayer.renderer = renderer;
                                    /* if (esriConfig && esriConfig.request && esriConfig.request.interceptors) {
                                        esriConfig.request.interceptors.push({
                                            urls: featureLayer.url + "/45",
                                            after(response) {
                                                console.dir(response);
                                                response.data.layers[0].legend.forEach((l: any) => {
                                                    l.label = "not " + l.label;
                                                }); 
                                            }
                                        });
                                    }*/
                                    console.debug(
                                        logNode +
                                            "layerview " +
                                            featureLayer.id +
                                            " done updating for first time. Resetting renderer.."
                                    );
                                }
                                const query = featureLayer.createQuery();
                                query.where = queryDef.queryDefinitionOriginal;

                                // if it is unwanted to show non-highlighted properties, set queryDefinition on layer to hide all non-selected objects
                                // eslint-disable-next-line no-unused-vars
                                const promiseQuery = new Promise((resolve, reject) => {
                                    featureLayer
                                        .queryFeatures(query)
                                        .then((result: any) => {
                                            const qfResult: QueryFeaturesResult = {
                                                layerName: layer.layerID,
                                                layerView: layerViewCurrent,
                                                arcGISObjectIDAttr: objectIdAttribute,
                                                result
                                            };
                                            whenFalseOnce(layerViewCurrent, "updating", () => {
                                                console.debug(logNode + qfResult.layerName + " layer updated after load"
                                                );
                                                resolve(qfResult);
                                            });
                                        })
                                        .catch((error: any) => reject(error));
                                });
                                promisesLayerQuery.push(promiseQuery);
                            }
                        }
                    }
                });
                Promise.all(promisesLayerQuery)
                    .then(results => {
                        console.debug(logNode + "all Query promises resolved, calling highlightAndZoom with " + results.length + " QF results");
                        Promise.all(
                            highlightAndZoom(highlights, results, view, props.objectZoom, true, props.dsHighlightingEnabled)
                        ).then(resolve);
                    })
                    .catch(error => {
                        console.error(
                            logNode + "failed to get all objects from all layers for zooming and highlighting, " + error
                        );
                        reject(error);
                    });
            } else {
                console.debug(logNode + "no Mendix Layers configured, hence not quering nor zooming..");
            }
        }
    })
};
export const createLoadingIndicators = (
    view: MapView,
    loadingBehavior: string,
    loadingModalMessage: string,
    progressIdRef: any,
    loadingDiv: any,
    blockProgressModalRef: any
): void => {
    // display the loading indicator when the view is updating
    whenTrue(view, "updating", () => {
        const messagePrefix = logNode + "updating view: " ;
        if (view.interacting || view.navigating){
            if (view.interacting) {
                console.debug(messagePrefix + "interacting (zooming)...");
            } else {
                console.debug(messagePrefix + "navigating...");
            }
        } else {
            //@ts-ignore
            if (view.activeTool && view.activeTool.type ==="draw-2d") {
                // undocumented feature. If a tool is activated it will be added to the view. if not, it doesn't exist, hence .type will give undefined error
                // do not add loading modal if actively drawing something...
                console.debug(messagePrefix + "drawing (selection tool)...");
            } //@ts-ignore
            else if (view.activeTool && view.activeTool._drawActive) {
                // undocumented feature. If a tool is activated it will be added to the view. if not, it doesn't exist, hence .type will give undefined error
                // do not add loading modal if actively drawing something...
                console.debug(messagePrefix + "measuring distance...");
            }
            else if (loadingBehavior === "modal" && !blockProgressModalRef.current) {
                progressIdRef.current = mx.ui.showProgress(loadingModalMessage, true);
                console.debug(logNode + "updating and showing progress modal with id" + progressIdRef.current);
                //@ts-ignore
                if (view.activeTool) {
                    //@ts-ignore
                    console.debug(logNode + "activeTool.type: " + view.activeTool.type);
                }
            }
            else if (loadingBehavior === "animatedGIF" && loadingDiv.current && !blockProgressModalRef.current) {
                loadingDiv.current.style.visibility = "";
            }
        }
    });
    // hide the loading indicator when the view stops updating
    whenFalse(view, "updating", () => {
        if (loadingBehavior === "modal" && progressIdRef.current) {
            mx.ui.hideProgress(progressIdRef.current);
            progressIdRef.current = undefined;
            // console.debug(logNode + " not updating anymore, so hiding progress modal with id" + progressIdRef.current);
        }
        else if (loadingBehavior === "animatedGIF" && loadingDiv.current) {
            loadingDiv.current.style.visibility = "hidden";
        }
        // console.error(logNode + "updating done..");
    });
}

export const loadLayer = (props: ArcGISContainerProps, layerObj: LayerArrayType, queryDefinitions: QueryDefinition[], mendixLayersRef: any, webMap: WebMap,
    view: MapView, promises: Promise<any>[]): void => {
    console.debug(logNode + "processing " + layerObj.layerServerType + " : " + layerObj.layerID);
    if (layerObj.layerServerType === "FeatureServer" || layerObj.layerServerType === "MapServer") {
        const layerID = layerObj.layerID;
        // console.debug(logNode + "start building layer: " + layerID);
        // get queryDefinition for layer based on layerID of MxObjects
        const queryDefinitionObj = queryDefinitions.filter(queryDefinition => {
            return queryDefinition.layerID === layerID;
        })[0];
        let queryDefinition = queryDefinitionObj.queryDefinition;
        // if all objects needs to be shown, don't use querydefinition when building the layer
        // but only for highligting these objects after all are loaded
        if (props.dsShowAllObjects) {
            queryDefinition = "1=1";
        }

        // console.debug(logNode + "Layer: " + layerID + " queryDefinition: " + queryDefinition);

        // get interaction attributes for layer based on layerID of MxObjects
        const intAttributesArrayLayer = props.intAttributesArray.filter(intAttribute => {
            if (intAttribute.intAttributeLayerID === layerID) {
                return {
                    fieldName: intAttribute.intAttributeName,
                    visible: true,
                    label: intAttribute.intAttributeLabel,
                    format: {
                        places: intAttribute.intAttributeDecimalPlaces,
                        digitSeparator: intAttribute.intAttributeDecimalSeparator
                    }
                };
            }
            return null;
        });
        const fieldInfos: FieldInfo[] = [];
        let inAttributeTitle = "";
        intAttributesArrayLayer.forEach(intAttribute => {
            const fieldInfo: FieldInfo = {
                fieldName: intAttribute.intAttributeName,
                visible: true,
                label: intAttribute.intAttributeLabel
            };
            fieldInfos.push(fieldInfo);
            if (intAttribute.intAttributeIsTitle) {
                inAttributeTitle = intAttribute.intAttributeName;
            }
        });
        // console.debug(logNode + "fieldinfos for layer " + layerID);
        // console.dir(fieldInfos);
        const btnId = "pop-mx-action-default-" + layerID;
        let intButtonIconClass = "";
        if (props.intButtonIcon?.value?.type === "glyph") {
            intButtonIconClass = " glyphicon " + props.intButtonIcon.value.iconClass;
        }
        // console.debug(logNode + "button icon:" + intButtonIconClass);
        // if (layerObj.layerServerType === "FeatureServer") {
        const actionArray = [];
        actionArray.push({
            title: props.intButtonLabel,
            id: btnId,
            className: props.intButtonClass + intButtonIconClass,
            type: "button"
        });

        let featureLayerSettings = {};
        // clustering needs to be enabled generically and on layer
        if (props.cl_enabled && layerObj.clusteringEnabled) {
            const featureReduction = {
                type: "cluster",
                clusterRadius: props.cl_radius + "px",
                // {cluster_count} is an aggregate field containing
                // the number of features comprised by the cluster
                popupTemplate: {
                    title: props.cl_popupTitle,
                    content: props.cl_popupContent,
                    fieldInfos: [
                        {
                            fieldName: "cluster_count",
                            format: {
                                places: 0,
                                digitSeparator: true
                            }
                        }
                    ]
                },
                clusterMinSize: props.cl_minSize + "px",
                clusterMaxSize: props.cl_maxSize + "px",
                labelingInfo: [
                    {
                        deconflictionStrategy: "none",
                        labelExpressionInfo: {
                            expression: "Text($feature.cluster_count, '#,###')"
                        },
                        symbol: {
                            type: "text",
                            color: props.cl_symbolTextColor,
                            font: {
                                weight: "bold",
                                family: "Noto Sans",
                                size: props.cl_symbolTextSize + "px"
                            }
                        },
                        labelPlacement: "center-center"
                    }
                ]
            };
            featureLayerSettings = {
                // URL to the service
                url: layerObj.layerURLStatic,
                definitionExpression: queryDefinition,
                featureReduction,
                popupTemplate: {
                    title: "{" + inAttributeTitle + "}",
                    content: [
                        {
                            type: "fields", // FieldsContentElement
                            fieldInfos
                        }
                    ],
                    actions: actionArray
                },
                outFields: ["*"]
            };
        } else if (layerObj.mendixLayer) {
            // if connected to Mendix objects enabled, dynamically populate popup with possibly Mendix attributes as well
            // if custom styling enabled, legend needs to be built up with a dummy extra layer,
            // because of shortcoming in unqiquevaluerenderer, generating duplicate legend entries.
            let legendEnabled = true;
            if (layerObj.customStylingEnabled) {
                legendEnabled = false;
            }
            featureLayerSettings = {
                // URL to the service
                url: layerObj.layerURLStatic,
                definitionExpression: queryDefinition,
                legendEnabled,
                popupTemplate: {
                    title: "{" + inAttributeTitle + "}",
                    outFields: ["*"],
                    content: (feature: any) => {
                        if (mendixLayersRef && mendixLayersRef.current) {
                            return createCustomContent(
                                feature,
                                intAttributesArrayLayer,
                                layerObj,
                                props.intMendixXPathStringr
                            );
                        }
                    },
                    actions: actionArray,
                    fieldInfos
                },
                outFields: ["*"]
            };
        } else {
            featureLayerSettings = {
                // URL to the service
                url: layerObj.layerURLStatic,
                definitionExpression: queryDefinition,
                popupTemplate: {
                    title: "{" + inAttributeTitle + "}",
                    outFields: ["*"],
                    content: [
                        {
                            type: "fields", // FieldsContentElement
                            fieldInfos
                        }
                    ],
                    actions: [],
                    fieldInfos
                },
                outFields: ["*"]
            };
        }

        // console.debug(logNode + layerObj.layerID + " : " + layerObj.layerServerType);
        const featureLayer = new FeatureLayer(featureLayerSettings);
        featureLayer.visible = layerObj.visibilityOnLoad;
        webMap.add(featureLayer, layerObj.layerIndex);
        if (layerObj.mendixLayer) {
            if (layerObj.customStylingEnabled) {
                const featureLayerLegendDummy = new FeatureLayer({
                    title: layerObj.layerID,
                    id: "Dummy",
                    source: [], // add no graphics as it is a dummy layer only used for adding legend of layers with custom styling
                    fields: [
                        {
                            name: "ObjectID",
                            alias: "ObjectID",
                            type: "oid"
                        },
                        {
                            name: "Name",
                            alias: "Name",
                            type: "string"
                        },
                        {
                            name: "Type",
                            alias: "Type",
                            type: "string"
                        }
                    ],
                    objectIdField: "ObjectID",
                    geometryType: "point",
                    spatialReference: { wkid: 4326 },
                    renderer: createLegendUniqueValueRender(props.csLegendEntriesArray, layerObj)
                });
                webMap.add(featureLayerLegendDummy, 0);
            }
            // need to wrap in promise to make sure layer is fully loaded when zooming, applying custom styling etc.
            const promiseLayer = new Promise(resolve => {
                view.whenLayerView(featureLayer).then(() => {
                    console.debug(
                        logNode + "loaded " + layerObj.layerServerType + " : " + layerObj.layerID
                    );
                    resolve(featureLayer);
                });
            });
            promises.push(promiseLayer);
        }
    } else if (layerObj.layerServerType === "PortalItem") {
        console.debug(logNode + "loading PortalItem with id: " + layerObj.portalItemID);
        Layer.fromPortalItem({
            portalItem: new PortalItem({
                id: layerObj.portalItemID // "dbd30266193b470a9adf795a38935bab"
            })
        }).then(layer => {
            // add the layer to the map
            webMap.add(layer, layerObj.layerIndex);
            layer.visible = layerObj.visibilityOnLoad;
        });
    }
}



================================================
FILE: typings/ReactArcGISProps.d.ts
================================================
/**
 * This file was generated from ReactArcGIS.xml
 * WARNING: All changes made to this file will be overwritten
 * @author Mendix UI Content Team
 */
import { CSSProperties } from "react";
import { DynamicValue, ListValue, ListActionValue, ListAttributeValue, WebIcon } from "mendix";

export type BmTogglePositionEnum = "bottomRight" | "bottomLeft" | "topRight" | "topLeft";

export type LoadingBehaviorEnum = "modal" | "animatedGIF" | "none";

export type LegendPositionEnum = "bottomRight" | "bottomLeft" | "topRight" | "topLeft";

export type SearchPositionEnum = "bottomRight" | "bottomLeft" | "topRight" | "topLeft";

export type ToggleLayerPositionEnum = "bottomRight" | "bottomLeft" | "topRight" | "topLeft";

export type LayerServerTypeEnum = "MapServer" | "FeatureServer" | "PortalItem";

export type ClientIDAttrTypeEnum = "String" | "Number";

export interface LayerArrayType {
    layerServerType: LayerServerTypeEnum;
    layerURLStatic: string;
    layerObjects?: ListValue;
    urlAttr?: ListAttributeValue<string>;
    layerID: string;
    layerIndex: number;
    objectIDAttr: string;
    clientIDAttr: string;
    clientIDAttrType: ClientIDAttrTypeEnum;
    featureLayerID: string;
    mendixLayer: boolean;
    portalItemID: string;
    visibleLayerIndexes: string;
    visibilityOnLoad: boolean;
    clusteringEnabled: boolean;
    customStylingEnabled: boolean;
    showAttribution: boolean;
    opacity: string;
}

export type CsDefaultArraySymbolEnum = "circle" | "cross" | "diamond" | "square" | "x";

export interface CsDefaultArrayType {
    csDefaultArrayLayerID: string;
    csDefaultArrayColor: string;
    csDefaultArraySize: number;
    csDefaultArraySymbol: CsDefaultArraySymbolEnum;
}

export type CsLegendEntrySymbolEnum = "circle" | "cross" | "diamond" | "square" | "x";

export interface CsLegendEntriesArrayType {
    csLegendEntryLayerID: string;
    csLegendEntryName: string;
    csLegendEntryColor: string;
    csLegendEntrySize: number;
    csLegendEntrySymbol: CsLegendEntrySymbolEnum;
}

export interface IntAttributesArrayType {
    intAttributeName: string;
    intAttributeMendix: boolean;
    intAttributeLabel: string;
    intAttributeLayerID: string;
    intAttributeIsTitle: boolean;
    intAttributeDecimalPlaces: number;
    intAttributeDecimalSeparator: string;
}

export interface LayerArrayPreviewType {
    layerServerType: LayerServerTypeEnum;
    layerURLStatic: string;
    layerObjects: {} | null;
    urlAttr: string;
    layerID: string;
    layerIndex: number | null;
    objectIDAttr: string;
    clientIDAttr: string;
    clientIDAttrType: ClientIDAttrTypeEnum;
    featureLayerID: string;
    mendixLayer: boolean;
    portalItemID: string;
    visibleLayerIndexes: string;
    visibilityOnLoad: boolean;
    clusteringEnabled: boolean;
    customStylingEnabled: boolean;
    showAttribution: boolean;
    opacity: string;
}

export interface CsDefaultArrayPreviewType {
    csDefaultArrayLayerID: string;
    csDefaultArrayColor: string;
    csDefaultArraySize: number | null;
    csDefaultArraySymbol: CsDefaultArraySymbolEnum;
}

export interface CsLegendEntriesArrayPreviewType {
    csLegendEntryLayerID: string;
    csLegendEntryName: string;
    csLegendEntryColor: string;
    csLegendEntrySize: number | null;
    csLegendEntrySymbol: CsLegendEntrySymbolEnum;
}

export interface IntAttributesArrayPreviewType {
    intAttributeName: string;
    intAttributeMendix: boolean;
    intAttributeLabel: string;
    intAttributeLayerID: string;
    intAttributeIsTitle: boolean;
    intAttributeDecimalPlaces: number | null;
    intAttributeDecimalSeparator: string;
}

export interface ReactArcGISContainerProps {
    name: string;
    class: string;
    style?: CSSProperties;
    tabIndex?: number;
    mapHeight: number;
    mapWidth: number;
    baseMapID: string;
    bmToggleEnabled: boolean;
    bmToggleID: string;
    bmTogglePosition: BmTogglePositionEnum;
    bmTogglePlaceHolderIndex: number;
    defaultY: number;
    defaultX: number;
    defaultZoom: number;
    singleObjectZoom: number;
    graphicObjects?: ListValue;
    objectIDAttr: ListAttributeValue<BigJs.Big | string>;
    layerIDAttr: ListAttributeValue<BigJs.Big | string>;
    colorAttr?: ListAttributeValue<string>;
    sizeAttr?: ListAttributeValue<BigJs.Big>;
    symbolAttr?: ListAttributeValue<string>;
    dsShowAllObjects: boolean;
    dsHighlightingEnabled: boolean;
    loadingBehavior: LoadingBehaviorEnum;
    loadingModalMessage: string;
    enableLegend: boolean;
    legendStartExpanded: boolean;
    legendTitle: string;
    legendPosition: LegendPositionEnum;
    legendPlaceholderIndex: number;
    enableSearch: boolean;
    searchStartExpanded: boolean;
    searchPosition: SearchPositionEnum;
    searchPlaceholderIndex: number;
    enableToggleLayer: boolean;
    toggleLayerStartExpanded: boolean;
    toggleLayerPosition: ToggleLayerPositionEnum;
    toggleLayerPlaceholderIndex: number;
    layerArray: LayerArrayType[];
    dynLayerObject?: ListValue;
    dynLayerLayerID?: ListAttributeValue<string>;
    dynLayerServerTypeAttr?: ListAttributeValue<string>;
    dynLayerVisibilityOnLoadAttr?: ListAttributeValue<boolean>;
    dynLayerEnableClusteringAttr?: ListAttributeValue<boolean>;
    dynLayerCustomStylingEnabledAttr?: ListAttributeValue<boolean>;
    dynLayerStaticURLAttr?: ListAttributeValue<string>;
    dynLayerObjectIDAttr?: ListAttributeValue<string>;
    dynLayerIndexAttr?: ListAttributeValue<BigJs.Big>;
    dynLayerMendixObjectsAttr?: ListAttributeValue<boolean>;
    csDefaultArray: CsDefaultArrayType[];
    csLegendEntriesArray: CsLegendEntriesArrayType[];
    intAttributesArray: IntAttributesArrayType[];
    intMendixXPathString: string;
    intButtonAction?: ListActionValue;
    intButtonLabel: string;
    intButtonClass: string;
    intButtonIcon?: DynamicValue<WebIcon>;
    cl_enabled: boolean;
    cl_symbolTextColor: string;
    cl_symbolTextSize: number;
    cl_popupTitle: string;
    cl_popupContent: string;
    cl_radius: number;
    cl_minSize: number;
    cl_maxSize: number;
}

export interface ReactArcGISPreviewProps {
    class: string;
    style: string;
    mapHeight: number | null;
    mapWidth: number | null;
    baseMapID: string;
    bmToggleEnabled: boolean;
    bmToggleID: string;
    bmTogglePosition: BmTogglePositionEnum;
    bmTogglePlaceHolderIndex: number | null;
    defaultY: number | null;
    defaultX: number | null;
    defaultZoom: number | null;
    singleObjectZoom: number | null;
    graphicObjects: {} | null;
    objectIDAttr: string;
    layerIDAttr: string;
    colorAttr: string;
    sizeAttr: string;
    symbolAttr: string;
    dsShowAllObjects: boolean;
    dsHighlightingEnabled: boolean;
    loadingBehavior: LoadingBehaviorEnum;
    loadingModalMessage: string;
    enableLegend: boolean;
    legendStartExpanded: boolean;
    legendTitle: string;
    legendPosition: LegendPositionEnum;
    legendPlaceholderIndex: number | null;
    enableSearch: boolean;
    searchStartExpanded: boolean;
    searchPosition: SearchPositionEnum;
    searchPlaceholderIndex: number | null;
    enableToggleLayer: boolean;
    toggleLayerStartExpanded: boolean;
    toggleLayerPosition: ToggleLayerPositionEnum;
    toggleLayerPlaceholderIndex: number | null;
    layerArray: LayerArrayPreviewType[];
    dynLayerObject: {} | null;
    dynLayerLayerID: string;
    dynLayerServerTypeAttr: string;
    dynLayerVisibilityOnLoadAttr: string;
    dynLayerEnableClusteringAttr: string;
    dynLayerCustomStylingEnabledAttr: string;
    dynLayerStaticURLAttr: string;
    dynLayerObjectIDAttr: string;
    dynLayerIndexAttr: string;
    dynLayerMendixObjectsAttr: string;
    csDefaultArray: CsDefaultArrayPreviewType[];
    csLegendEntriesArray: CsLegendEntriesArrayPreviewType[];
    intAttributesArray: IntAttributesArrayPreviewType[];
    intMendixXPathString: string;
    intButtonAction: {} | null;
    intButtonLabel: string;
    intButtonClass: string;
    intButtonIcon: { type: "glyph"; iconClass: string; } | { type: "image"; imageUrl: string; } | null;
    cl_enabled: boolean;
    cl_symbolTextColor: string;
    cl_symbolTextSize: number | null;
    cl_popupTitle: string;
    cl_popupContent: string;
    cl_radius: number | null;
    cl_minSize: number | null;
    cl_maxSize: number | null;
}


